{
  "api/Editor.Scripts.ConvertToTrainARObject.html": {
    "href": "api/Editor.Scripts.ConvertToTrainARObject.html",
    "title": "Class ConvertToTrainARObject | TrainAR Documentation",
    "keywords": "Class ConvertToTrainARObject ConvertToTrainARObjects is an Editor script that adds a right-click context menu to GameObjects in the hierarchy named \"Convert to TrainAR Object\". When the object is eligible (therefore has a transform, MeshFilter and MeshRenderer), this can be used to convert GameObjects to TrainAR Objects, where behaviours (e.g. TrainAR Object) are automatically added and the mesh is combined an simplyfied. Inheritance Object ConvertToTrainARObject Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class ConvertToTrainARObject : UnityEditor.Editor Methods | Improve this Doc View Source AddConvertionContextItem() Adds the \"Convert to TrainAR Object\" menu Item to the context menu in the editor and handles when it was clicked. Declaration public static void AddConvertionContextItem() | Improve this Doc View Source CombineMeshes(GameObject) Combines all meshes of the selected object (e.g. all meshes in child structures) into a singular mesh, saving it into the Models folder and deleting all the children to make the mesh structure work with TrainAR. Declaration public static GameObject CombineMeshes(GameObject objectToCombineAllMeshesFor) Parameters Type Name Description GameObject objectToCombineAllMeshesFor The GameObject which meshes (parent and child) should be combined Returns Type Description GameObject | Improve this Doc View Source FinalizeConversion(GameObject, GameObject, String) Finalizes the conversion process for the given object, replacing the original object in the scene. Declaration public static void FinalizeConversion(GameObject originalObject, GameObject instantiatedPreviewObject, string trainARObjectName) Parameters Type Name Description GameObject originalObject The original GameObject in the scene. GameObject instantiatedPreviewObject The instantiated copy of the GameObject. String trainARObjectName The specified name of the TrainAR Object. | Improve this Doc View Source SimplifyMeshesUsingQuadrics(IEnumerable<UnityEngine.Mesh>, GameObject, Single, Boolean, Boolean, Boolean, Boolean) Uses the Meshsimplifier to decimate the mesh of the passed Gameobject as well as all of it's children's meshes. Note: In the current implementation this only simplifies one single mesh but it works so i leave this as it is here. Declaration public static void SimplifyMeshesUsingQuadrics(IEnumerable<UnityEngine.Mesh> originalMeshes, GameObject currentSelectedObject, float quality, bool preserveBorderEdges = false, bool preserveSurfaceCurvature = false, bool preserveUVSeamEdges = false, bool preserveUVFoldoverEdges = false) Parameters Type Name Description IEnumerable < UnityEngine.Mesh > originalMeshes The meshes as they were, when the object was originally selected, before any mesh changes were applied GameObject currentSelectedObject The current Gameobject, to which the mesh changes are applied to Single quality The desired quality of the simplification. Must be between 0 and 1. Boolean preserveBorderEdges Optional parameter: Should mesh edges be preserved? Boolean preserveSurfaceCurvature Optional parameter: Should surface curvature be preserved? Boolean preserveUVSeamEdges Optional parameter: Should UV seam edges be preserved? Boolean preserveUVFoldoverEdges Optional parameter: Should UV foldover edges be preserved? | Improve this Doc View Source SimplifyMeshesUsingTridecimator(UnityEngine.Mesh, Int32) Simplifies one given mesh (careful, this is different to the SimplifyMeshesUsingQuadrics method, which simplifies all meshes of a given object) to the given target polygon count using the Tridecimator method from the UnityMeshDecimation package. Declaration public static UnityEngine.Mesh SimplifyMeshesUsingTridecimator(UnityEngine.Mesh providedMesh, int targetMeshPolygons) Parameters Type Name Description UnityEngine.Mesh providedMesh The Mesh to simplify Int32 targetMeshPolygons the target polygon count to simplify to Returns Type Description UnityEngine.Mesh The simplified mesh"
  },
  "api/Editor.Scripts.EditorTrainARObjectToolbar.html": {
    "href": "api/Editor.Scripts.EditorTrainARObjectToolbar.html",
    "title": "Class EditorTrainARObjectToolbar | TrainAR Documentation",
    "keywords": "Class EditorTrainARObjectToolbar The EditorTrainARObjectToolbar is the toolbar in the sceneview when using the TrainAR authoring overlay. It allows setting TrainAR Object states like active/inactive, grabbable, interactable, or combinable without opening an inspector. Inheritance Object EditorTrainARObjectToolbar Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class EditorTrainARObjectToolbar : ToolbarOverlay Methods | Improve this Doc View Source OnCreated() OnCreated is invoked when an Overlay is instantiated in an Overlay Canvas. Declaration public override void OnCreated() | Improve this Doc View Source OnWillBeDestroyed() Called when an Overlay is about to be destroyed. Declaration public override void OnWillBeDestroyed()"
  },
  "api/Editor.Scripts.html": {
    "href": "api/Editor.Scripts.html",
    "title": "Namespace Editor.Scripts | TrainAR Documentation",
    "keywords": "Namespace Editor.Scripts Classes ConvertToTrainARObject ConvertToTrainARObjects is an Editor script that adds a right-click context menu to GameObjects in the hierarchy named \"Convert to TrainAR Object\". When the object is eligible (therefore has a transform, MeshFilter and MeshRenderer), this can be used to convert GameObjects to TrainAR Objects, where behaviours (e.g. TrainAR Object) are automatically added and the mesh is combined an simplyfied. EditorTrainARObjectToolbar The EditorTrainARObjectToolbar is the toolbar in the sceneview when using the TrainAR authoring overlay. It allows setting TrainAR Object states like active/inactive, grabbable, interactable, or combinable without opening an inspector. MeshCombinerEditor The MeshCombinerEditor is a utility class that helps to combine meshes. OpenAuthoringToolOnLoad Every time the editor is started, trigger switching to the TrainAR authoring tool. PlayModeButtonOverride The PlayModeButtonOverride editor script implements utility for the unity editor play buttons that overrides its functionality with TrainAR specific functionality to either switch the build target if there is an unsupported one currently selected or allow building to a device by clicking the play button. This is done for convenience of building and also to prevent the playmode execution, as this is currently not supported by the framework. StateRequestSimulatorEditor Adds the GUI to the inspector to simulate stateRequests to test the statemachine in the editor. This is an Unity Editor Utility Class for the \"StateRequestSimulator\" class. TrainARConvertObjectToolbar Displays and initializes the editor toolbar which contains a button that initializes the conversion process for a TrainAR Object of the currently selected object. TrainAREditorMenu The TrainAREditorMenu adds a top menu with options called \"TrainAR\" for trainAR specific funtionallity like building, switching plattform, switching the mode (TrainAR/Unity Editor), and other options. TrainARObjectConversionWindow Instance of the Editor Window with enables the user to specify options for the TrainAR Object and initializes the conversion process. TrainARObjectOffsetToolbar The TrainARObjectOffsetToolbar is a toolbar in the Scene view when using the TrainAR authoring overlay. It is displayed instead of the TrainARObjectToolbar when two objects are selected in the editor. It displays the positional and rotational offsets between the two selected objects, so the user can use them, e.g. for the FuseObjects functionality of the object helper node."
  },
  "api/Editor.Scripts.MeshCombinerEditor.html": {
    "href": "api/Editor.Scripts.MeshCombinerEditor.html",
    "title": "Class MeshCombinerEditor | TrainAR Documentation",
    "keywords": "Class MeshCombinerEditor The MeshCombinerEditor is a utility class that helps to combine meshes. Inheritance Object MeshCombinerEditor Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class MeshCombinerEditor : UnityEditor.Editor Methods | Improve this Doc View Source OnInspectorGUI() The inspector of the MeshCombinerEditor adds the option to reference meshes which are skipped in the combine process. The combined mesh is stored in the location which is defined in this inspector. Declaration public override void OnInspectorGUI() | Improve this Doc View Source SaveCombinedMesh(Mesh, String) Saves the given mesh at the given location. Creates the directories if the given path doesn't exits. Declaration public static string SaveCombinedMesh(Mesh mesh, string folderPath) Parameters Type Name Description Mesh mesh Any to store mesh. String folderPath The path where to store the given mesh. Returns Type Description String The path where the mesh is stored"
  },
  "api/Editor.Scripts.OpenAuthoringToolOnLoad.html": {
    "href": "api/Editor.Scripts.OpenAuthoringToolOnLoad.html",
    "title": "Class OpenAuthoringToolOnLoad | TrainAR Documentation",
    "keywords": "Class OpenAuthoringToolOnLoad Every time the editor is started, trigger switching to the TrainAR authoring tool. Inheritance Object OpenAuthoringToolOnLoad Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class OpenAuthoringToolOnLoad"
  },
  "api/Editor.Scripts.PlayModeButtonOverride.html": {
    "href": "api/Editor.Scripts.PlayModeButtonOverride.html",
    "title": "Class PlayModeButtonOverride | TrainAR Documentation",
    "keywords": "Class PlayModeButtonOverride The PlayModeButtonOverride editor script implements utility for the unity editor play buttons that overrides its functionality with TrainAR specific functionality to either switch the build target if there is an unsupported one currently selected or allow building to a device by clicking the play button. This is done for convenience of building and also to prevent the playmode execution, as this is currently not supported by the framework. Inheritance Object PlayModeButtonOverride Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public static class PlayModeButtonOverride Methods | Improve this Doc View Source BuildAndDeployProjectToDevice() Build and Runs the project for the current build target. Declaration public static bool BuildAndDeployProjectToDevice() Returns Type Description Boolean True, if the build succeeded | Improve this Doc View Source ShowDialogBoxForBuilding() Shows a Unity Editor Dialog box asking the user if he wants to build the Project. Declaration public static void ShowDialogBoxForBuilding() | Improve this Doc View Source SwitchBuildTargetToAndroid() Switches Unity Build Target to Android. Declaration public static void SwitchBuildTargetToAndroid() | Improve this Doc View Source SwitchBuildTargetToIOS() Switches Unity Build Target to iOS. Declaration public static void SwitchBuildTargetToIOS()"
  },
  "api/Editor.Scripts.StateRequestSimulatorEditor.html": {
    "href": "api/Editor.Scripts.StateRequestSimulatorEditor.html",
    "title": "Class StateRequestSimulatorEditor | TrainAR Documentation",
    "keywords": "Class StateRequestSimulatorEditor Adds the GUI to the inspector to simulate stateRequests to test the statemachine in the editor. This is an Unity Editor Utility Class for the \"StateRequestSimulator\" class. Inheritance Object StateRequestSimulatorEditor Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class StateRequestSimulatorEditor : UnityEditor.Editor Methods | Improve this Doc View Source OnInspectorGUI() Adds the inspector GUI. Declaration public override void OnInspectorGUI()"
  },
  "api/Editor.Scripts.TrainARConvertObjectToolbar.html": {
    "href": "api/Editor.Scripts.TrainARConvertObjectToolbar.html",
    "title": "Class TrainARConvertObjectToolbar | TrainAR Documentation",
    "keywords": "Class TrainARConvertObjectToolbar Displays and initializes the editor toolbar which contains a button that initializes the conversion process for a TrainAR Object of the currently selected object. Inheritance Object TrainARConvertObjectToolbar Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class TrainARConvertObjectToolbar : Overlay Methods | Improve this Doc View Source CreatePanelContent() Creates the Panel that displays the toolbar. Declaration public override VisualElement CreatePanelContent() Returns Type Description VisualElement | Improve this Doc View Source OnCreated() Declaration public override void OnCreated() | Improve this Doc View Source OnWillBeDestroyed() Declaration public override void OnWillBeDestroyed()"
  },
  "api/Editor.Scripts.TrainAREditorMenu.html": {
    "href": "api/Editor.Scripts.TrainAREditorMenu.html",
    "title": "Class TrainAREditorMenu | TrainAR Documentation",
    "keywords": "Class TrainAREditorMenu The TrainAREditorMenu adds a top menu with options called \"TrainAR\" for trainAR specific funtionallity like building, switching plattform, switching the mode (TrainAR/Unity Editor), and other options. Inheritance Object TrainAREditorMenu Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class TrainAREditorMenu : UnityEditor.Editor Methods | Improve this Doc View Source BuildToDevice() Build and Runs the current solution when clicked. Declaration public static void BuildToDevice() | Improve this Doc View Source HideFrameworkHierarchy() Hides the framework GameObject in the hierarchy when clicked. Declaration public static void HideFrameworkHierarchy() | Improve this Doc View Source HideTrainARReferenceScene() Hides the TrainAR reference setup in the scene when clicked. Declaration public static void HideTrainARReferenceScene() | Improve this Doc View Source OpenDocumentation() Opens the Documentation when clicked. Declaration public static void OpenDocumentation() | Improve this Doc View Source OpenTrainARScene() Opens the default TrainAR scene when clicked. Declaration public static void OpenTrainARScene() | Improve this Doc View Source ResetStatemachineToDefault() Opens the default statemachine in the visual scripting window when clicked. Declaration public static void ResetStatemachineToDefault() | Improve this Doc View Source ResetTrainARSceneToAuthoringToolDefault() Resets the scene camera to a pivot point, rotation and distance that looks good in the Scene. Declaration public static void ResetTrainARSceneToAuthoringToolDefault() | Improve this Doc View Source ShowFrameworkHierarchy() Shows the framework GameObject in the hierarchy when clicked. Declaration public static void ShowFrameworkHierarchy() | Improve this Doc View Source SwitchToAndroid() Switches the current platform to Android when clicked. Declaration public static void SwitchToAndroid() | Improve this Doc View Source SwitchToIOS() Switches the current platform to iOS when clicked. Declaration public static void SwitchToIOS() | Improve this Doc View Source SwitchToTrainARMode() Switches the Editor Layout to TrainAR Authoring mode when clicked. Declaration public static void SwitchToTrainARMode() | Improve this Doc View Source SwitchToUnityMode() Switches the Editor Layout to the default Unity Layout when clicked. Declaration public static void SwitchToUnityMode()"
  },
  "api/Editor.Scripts.TrainARObjectConversionWindow.html": {
    "href": "api/Editor.Scripts.TrainARObjectConversionWindow.html",
    "title": "Class TrainARObjectConversionWindow | TrainAR Documentation",
    "keywords": "Class TrainARObjectConversionWindow Instance of the Editor Window with enables the user to specify options for the TrainAR Object and initializes the conversion process. Inheritance Object TrainARObjectConversionWindow Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class TrainARObjectConversionWindow : EditorWindow Methods | Improve this Doc View Source WindowWithObjectAlreadyExists(GameObject) Checks whether or not a TrainARObjectConversionWindow with the given Gameobject is already active. Declaration public static bool WindowWithObjectAlreadyExists(GameObject gameObject) Parameters Type Name Description GameObject gameObject The Gameobject to be checked. Returns Type Description Boolean True if a TrainARObjectConversionWindow with the given Gameobject already exists."
  },
  "api/Editor.Scripts.TrainARObjectOffsetToolbar.html": {
    "href": "api/Editor.Scripts.TrainARObjectOffsetToolbar.html",
    "title": "Class TrainARObjectOffsetToolbar | TrainAR Documentation",
    "keywords": "Class TrainARObjectOffsetToolbar The TrainARObjectOffsetToolbar is a toolbar in the Scene view when using the TrainAR authoring overlay. It is displayed instead of the TrainARObjectToolbar when two objects are selected in the editor. It displays the positional and rotational offsets between the two selected objects, so the user can use them, e.g. for the FuseObjects functionality of the object helper node. Inheritance Object TrainARObjectOffsetToolbar Namespace : Editor.Scripts Assembly : Assembly-CSharp-Editor.dll Syntax public class TrainARObjectOffsetToolbar : Overlay Methods | Improve this Doc View Source CreatePanelContent() Creates the Panel that displays the toolbar Declaration public override VisualElement CreatePanelContent() Returns Type Description VisualElement | Improve this Doc View Source OnCreated() Declaration public override void OnCreated() | Improve this Doc View Source OnWillBeDestroyed() Declaration public override void OnWillBeDestroyed()"
  },
  "api/Interaction.AudioController.html": {
    "href": "api/Interaction.AudioController.html",
    "title": "Class AudioController | TrainAR Documentation",
    "keywords": "Class AudioController The AudioController is a behaviour automatically attached to a TrainAR Object on conversion. It triggers its sounds for selection, deselection, grabbing, releasing and correct/incorrect interactions/combinations specific to this object. When attached, it holds default sounds. Those can be replaced in the Unity Editor Inspector. Inheritance Object AudioController Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class AudioController : MonoBehaviour Fields | Improve this Doc View Source CombineSound The audioclip that is played when a TrainAR Object is combined with. This only plays when the statemachine accepts the statechange. Declaration public AudioClip CombineSound Field Value Type Description AudioClip Default clip is referenced. If none is referenced it gets ignored. | Improve this Doc View Source DeselectSound The audioclip that is played when a TrainAR Object is deselected. Declaration public AudioClip DeselectSound Field Value Type Description AudioClip Default clip is referenced. If none is referenced it gets ignored. | Improve this Doc View Source ErrorSound The audioclip that is played when a requested interaction with this object was denied by the statemachine. Declaration public AudioClip ErrorSound Field Value Type Description AudioClip Default clip is referenced. If none is referenced it gets ignored. | Improve this Doc View Source GrabSound The audioclip that is played when a TrainAR Object is grabbed. Declaration public AudioClip GrabSound Field Value Type Description AudioClip Default clip is referenced. If none is referenced it gets ignored. | Improve this Doc View Source InteractSound The audioclip that is played when a TrainAR Object is interacted with. This only plays when the statemachine accepts the statechange. Declaration public AudioClip InteractSound Field Value Type Description AudioClip Default clip is referenced. If none is referenced it gets ignored. | Improve this Doc View Source ReleaseSound The audioclip that is played when a TrainAR Object is released. Declaration public AudioClip ReleaseSound Field Value Type Description AudioClip Default clip is referenced. If none is referenced it gets ignored. | Improve this Doc View Source SelectSound The audioclip that is played when a TrainAR Object is selected. Declaration public AudioClip SelectSound Field Value Type Description AudioClip Default clip is referenced. If none is referenced it gets ignored."
  },
  "api/Interaction.CollisionController.html": {
    "href": "api/Interaction.CollisionController.html",
    "title": "Class CollisionController | TrainAR Documentation",
    "keywords": "Class CollisionController Detects and handles collisions of TrainAR Objects. This is e.g. used for combining GameObjects and visualizing interseted states through outlining and shading. Inheritance Object CollisionController Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class CollisionController : MonoBehaviour Fields | Improve this Doc View Source boxCollider Holds a reference to the BoxCollider of the attached Gameobject. Declaration public BoxCollider boxCollider Field Value Type Description BoxCollider Boundingbox with dimensions of the mesh. | Improve this Doc View Source grabbedObject Holds a reference to the currently grabbed TrainAR object. Declaration public GameObject grabbedObject Field Value Type Description GameObject Is changed depending on the grabbed object."
  },
  "api/Interaction.CollisionController.Intersection.html": {
    "href": "api/Interaction.CollisionController.Intersection.html",
    "title": "Struct CollisionController.Intersection | TrainAR Documentation",
    "keywords": "Struct CollisionController.Intersection The struct that holds references of intersections. Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public struct Intersection Constructors | Improve this Doc View Source Intersection(GameObject, Boolean) Constructer to create a struct to store references for a detected intersection. Declaration public Intersection(GameObject intersectedObject, bool intersectionDetected) Parameters Type Name Description GameObject intersectedObject The intersected TrainAR object. Boolean intersectionDetected If a intersection is detected Methods | Improve this Doc View Source GetIntersectedObject() Get the intersected TrainAR object reference in the struct. Declaration public GameObject GetIntersectedObject() Returns Type Description GameObject The TrainAR gameobject. | Improve this Doc View Source GetIntersectionDetected() Get if a intersection is detected. Declaration public bool GetIntersectionDetected() Returns Type Description Boolean If a intersection is detected. | Improve this Doc View Source SetIntersectedObject(GameObject) Set the intersected TrainAR object reference in the struct. Declaration public void SetIntersectedObject(GameObject intersectedObject) Parameters Type Name Description GameObject intersectedObject The intersected Object. | Improve this Doc View Source SetIntersectionDetected(Boolean) Set if a intersection is detected. Declaration public void SetIntersectionDetected(bool intersectionDetected) Parameters Type Name Description Boolean intersectionDetected True if intersection is detected."
  },
  "api/Interaction.CrosshairController.html": {
    "href": "api/Interaction.CrosshairController.html",
    "title": "Class CrosshairController | TrainAR Documentation",
    "keywords": "Class CrosshairController The CrosshairController activates/deactivates the crosshair which is positioned in the middle of the screen. This can e.g. happen when an object is grabbed or an overlay is active. Inheritance Object CrosshairController Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class CrosshairController : MonoBehaviour Fields | Improve this Doc View Source contextButtonsAreActive Changes depending if the contextButtons are active. Declaration public bool contextButtonsAreActive Field Value Type Description Boolean True if contextButtons are active. Methods | Improve this Doc View Source ActivateContextButtons() Activates the context buttons. Declaration public void ActivateContextButtons() | Improve this Doc View Source ActivateCrosshair() Activate the crosshair. Declaration public void ActivateCrosshair() | Improve this Doc View Source DeactivateContextButtons() Deactivates the context buttons. Declaration public void DeactivateContextButtons() | Improve this Doc View Source DeactivateCrosshair() Deactivates the crosshair. Declaration public void DeactivateCrosshair()"
  },
  "api/Interaction.html": {
    "href": "api/Interaction.html",
    "title": "Namespace Interaction | TrainAR Documentation",
    "keywords": "Namespace Interaction Classes AudioController The AudioController is a behaviour automatically attached to a TrainAR Object on conversion. It triggers its sounds for selection, deselection, grabbing, releasing and correct/incorrect interactions/combinations specific to this object. When attached, it holds default sounds. Those can be replaced in the Unity Editor Inspector. CollisionController Detects and handles collisions of TrainAR Objects. This is e.g. used for combining GameObjects and visualizing interseted states through outlining and shading. CrosshairController The CrosshairController activates/deactivates the crosshair which is positioned in the middle of the screen. This can e.g. happen when an object is grabbed or an overlay is active. InteractionController Handles the interactions, i.e. grabbing, releasing, interacting and combining of the TrainARObjects. MaterialController Handles material related functionality for TrainAR objects. ObjectLerpingController When TrainAR objects are grabbed, they lerp towards to correct position attached to the camera instead of appearing there. The ObjectLerpingController handles the lerping towards the camera when the object is grabbed. Outline The Outline script is automatically attached to TrainAR objects on conversion and handles the outlining for e.g. selection, success or failure. It is called and handled by the MaterialController. ResetLostObjectController The ResetLostObjectController resets TrainAR objects back to the original spawn point when they are released too far away of the assembly. This is to prevent objects from falling through the infinityPlane or disapearing when release while the training assembly has tracking problems and \"flaots\" away. RigidbodyController The RigidbodyController is attached to TrainAR object on conversion. It handles the activation and deactivation of physics, as we do want TrainAR objects to elicit physics when released but not when stationary as this could e.g. cause users to \"knock over\" the assembly with grabbed objects. TrainARObject The main behaviour script for a TrainAR object. This is automatically added when converting GameObject to TrainAR objects After adding this script all following RequiredComponents are added. SelectionBase, MeshCollider, BoxCollider, RigidbodyController, MaterialController, AudioController, Rigidbody, Outline, CollisionController. The TrainAR events that are triggered on actions are also defined in this script. TrainARObject.CustomUnityEvent The CustomUnityEvent that is used for the OnCombination event. This Event also passes a string with its invocation indicating the other to be combined with TrainAR objects name. Structs CollisionController.Intersection The struct that holds references of intersections. Enums Outline.Mode Differentiates the type of the outlines used."
  },
  "api/Interaction.InteractionController.html": {
    "href": "api/Interaction.InteractionController.html",
    "title": "Class InteractionController | TrainAR Documentation",
    "keywords": "Class InteractionController Handles the interactions, i.e. grabbing, releasing, interacting and combining of the TrainARObjects. Inheritance Object InteractionController Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class InteractionController : MonoBehaviour Fields | Improve this Doc View Source grabbedObject The object that is currently grabbed by the user. Declaration public GameObject grabbedObject Field Value Type Description GameObject Changed when TrainAR object is grabbed/released. | Improve this Doc View Source grabber Reference to the grabber object, which becomes the parent of a picked up (grabbed) TrainAR-object. Declaration public GameObject grabber Field Value Type Description GameObject One grabber per scene. | Improve this Doc View Source hit Raycast from the center of the screen to detected if a TrainAR object is aimed at. Declaration public RaycastHit hit Field Value Type Description RaycastHit Null if no gameObject is hit. | Improve this Doc View Source intersectedObject Reference to the intersected TrainAR object. Declaration public GameObject intersectedObject Field Value Type Description GameObject Changed when TrainAR object are intersecting. | Improve this Doc View Source isGrabbingObject Changes value when an object is grabbed/released. Declaration public bool isGrabbingObject Field Value Type Description Boolean True if a object is grabbed. | Improve this Doc View Source isIntersecting Changed on intersection. Declaration public bool isIntersecting Field Value Type Description Boolean True if TrainAR objects ar intersecting. | Improve this Doc View Source isSelectingObject Changed when TrainAR object is selected/deselected. Declaration public bool isSelectingObject Field Value Type Description Boolean True if a object is selected. | Improve this Doc View Source selectedObject Reference to the current selected(aimed at) TrainAR object. Declaration public GameObject selectedObject Field Value Type Description GameObject Changed on selection. | Improve this Doc View Source tryedGrabbingObjectUnsuccessfully Value is changed when the grab button is pressed. Declaration public bool tryedGrabbingObjectUnsuccessfully Field Value Type Description Boolean True if a grabbing of an object was not successfull. Methods | Improve this Doc View Source Combine() Invokes the Combine on the TrainARObject. Important: This method assumes there is an object selected and it is currently intersecting with another. It also assumes that ARInteractables have an ObjectInteraktionhandler. Declaration public void Combine() | Improve this Doc View Source GrabObject() Grab the object that is currently selected by the raycast. Declaration public void GrabObject() | Improve this Doc View Source Interact() Invokes the Interact on the TrainARObject. Important: This method assumes there is an object selected! It also assumes that ARInteractables have an ObjectInteraktionhandler. Declaration public void Interact() | Improve this Doc View Source ReleaseGrabbedObject(Boolean) Release the currently grabbed object. Declaration public void ReleaseGrabbedObject(bool fusedObject = false) Parameters Type Name Description Boolean fusedObject"
  },
  "api/Interaction.MaterialController.html": {
    "href": "api/Interaction.MaterialController.html",
    "title": "Class MaterialController | TrainAR Documentation",
    "keywords": "Class MaterialController Handles material related functionality for TrainAR objects. Inheritance Object MaterialController Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class MaterialController : MonoBehaviour Methods | Improve this Doc View Source ActivateErrorIndicator() Play Error outline animation in coroutine. Declaration public void ActivateErrorIndicator() | Improve this Doc View Source ActivateOutlines() Activates the Outline of the object. Declaration public void ActivateOutlines() | Improve this Doc View Source ActivateSuccessIndicator() Play Success outline animation in coroutine. Declaration public void ActivateSuccessIndicator() | Improve this Doc View Source ActivateSuccessIndicator(String) Play Success outline animation in coroutine. Declaration public void ActivateSuccessIndicator(string CombinedWith) Parameters Type Name Description String CombinedWith | Improve this Doc View Source ChangeToCombineMaterial() Replaces all materials on the this Object with a material for combining. Declaration public void ChangeToCombineMaterial() | Improve this Doc View Source DeactivateOutlines() Deactivates the Outline of the object. Declaration public void DeactivateOutlines() | Improve this Doc View Source resetOriginalMaterial() Resets the current materials back to original materials of the object. Declaration public void resetOriginalMaterial() | Improve this Doc View Source setNewOriginalMaterial(GameObject, Material) Change the original material of the given object with to a new material. Declaration public void setNewOriginalMaterial(GameObject gameObject, Material newMaterial) Parameters Type Name Description GameObject gameObject The gameobject where the material is changed. Material newMaterial The new material."
  },
  "api/Interaction.ObjectLerpingController.html": {
    "href": "api/Interaction.ObjectLerpingController.html",
    "title": "Class ObjectLerpingController | TrainAR Documentation",
    "keywords": "Class ObjectLerpingController When TrainAR objects are grabbed, they lerp towards to correct position attached to the camera instead of appearing there. The ObjectLerpingController handles the lerping towards the camera when the object is grabbed. Inheritance Object ObjectLerpingController Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class ObjectLerpingController : MonoBehaviour"
  },
  "api/Interaction.Outline.html": {
    "href": "api/Interaction.Outline.html",
    "title": "Class Outline | TrainAR Documentation",
    "keywords": "Class Outline The Outline script is automatically attached to TrainAR objects on conversion and handles the outlining for e.g. selection, success or failure. It is called and handled by the MaterialController. Inheritance Object Outline Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class Outline : MonoBehaviour Properties | Improve this Doc View Source OutlineColor The color of the outline. Declaration public Color OutlineColor { get; set; } Property Value Type Description Color | Improve this Doc View Source OutlineMode The type of outline used. (e.g. if it shows through other objects) Declaration public Outline.Mode OutlineMode { get; set; } Property Value Type Description Outline.Mode | Improve this Doc View Source OutlineWidth The width/thickness of the outline. Declaration public float OutlineWidth { get; set; } Property Value Type Description Single"
  },
  "api/Interaction.Outline.Mode.html": {
    "href": "api/Interaction.Outline.Mode.html",
    "title": "Enum Outline.Mode | TrainAR Documentation",
    "keywords": "Enum Outline.Mode Differentiates the type of the outlines used. Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public enum Mode Fields Name Description OutlineAll OutlineAndSilhouette OutlineHidden OutlineVisible SilhouetteOnly"
  },
  "api/Interaction.ResetLostObjectController.html": {
    "href": "api/Interaction.ResetLostObjectController.html",
    "title": "Class ResetLostObjectController | TrainAR Documentation",
    "keywords": "Class ResetLostObjectController The ResetLostObjectController resets TrainAR objects back to the original spawn point when they are released too far away of the assembly. This is to prevent objects from falling through the infinityPlane or disapearing when release while the training assembly has tracking problems and \"flaots\" away. Inheritance Object ResetLostObjectController Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class ResetLostObjectController : MonoBehaviour"
  },
  "api/Interaction.RigidbodyController.html": {
    "href": "api/Interaction.RigidbodyController.html",
    "title": "Class RigidbodyController | TrainAR Documentation",
    "keywords": "Class RigidbodyController The RigidbodyController is attached to TrainAR object on conversion. It handles the activation and deactivation of physics, as we do want TrainAR objects to elicit physics when released but not when stationary as this could e.g. cause users to \"knock over\" the assembly with grabbed objects. Inheritance Object RigidbodyController Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class RigidbodyController : MonoBehaviour"
  },
  "api/Interaction.TrainARObject.CustomUnityEvent.html": {
    "href": "api/Interaction.TrainARObject.CustomUnityEvent.html",
    "title": "Class TrainARObject.CustomUnityEvent | TrainAR Documentation",
    "keywords": "Class TrainARObject.CustomUnityEvent The CustomUnityEvent that is used for the OnCombination event. This Event also passes a string with its invocation indicating the other to be combined with TrainAR objects name. Inheritance Object TrainARObject.CustomUnityEvent Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax [Serializable] public class CustomUnityEvent : UnityEvent<string>"
  },
  "api/Interaction.TrainARObject.html": {
    "href": "api/Interaction.TrainARObject.html",
    "title": "Class TrainARObject | TrainAR Documentation",
    "keywords": "Class TrainARObject The main behaviour script for a TrainAR object. This is automatically added when converting GameObject to TrainAR objects After adding this script all following RequiredComponents are added. SelectionBase, MeshCollider, BoxCollider, RigidbodyController, MaterialController, AudioController, Rigidbody, Outline, CollisionController. The TrainAR events that are triggered on actions are also defined in this script. Inheritance Object TrainARObject Namespace : Interaction Assembly : Assembly-CSharp.dll Syntax public class TrainARObject : MonoBehaviour Fields | Improve this Doc View Source error Error event. Triggered when an action is triggered on this TrainAR object that was not accepted by the statemachine. Declaration public UnityEvent error Field Value Type Description UnityEvent | Improve this Doc View Source interactableName The name of the TrainAR object that is used for the statemachine check. By default, this is the name of the TrainAR object. Declaration public string interactableName Field Value Type Description String String based on the object name. | Improve this Doc View Source Intersection The Object this object is currently intersecting with. Declaration public CollisionController.Intersection Intersection Field Value Type Description CollisionController.Intersection Is set on runtime. | Improve this Doc View Source isCombineable Is the object combineable? Declaration public bool isCombineable Field Value Type Description Boolean If true it is combinable. | Improve this Doc View Source isGrabbable Is the object grabbable? Declaration public bool isGrabbable Field Value Type Description Boolean If true it is grabbable. | Improve this Doc View Source isGrabbed Declaration public bool isGrabbed Field Value Type Description Boolean | Improve this Doc View Source isInteractable Is the object interactable? Declaration public bool isInteractable Field Value Type Description Boolean If true it is interactable. | Improve this Doc View Source isSelected Declaration public bool isSelected Field Value Type Description Boolean | Improve this Doc View Source lerpingDistance The distance in front of the camera, where the object is lerped to. This can e.g. be useful, if objects are larger than usual. Declaration public float lerpingDistance Field Value Type Description Single Default is 0.2f | Improve this Doc View Source OnCombination Declaration public TrainARObject.CustomUnityEvent OnCombination Field Value Type Description TrainARObject.CustomUnityEvent | Improve this Doc View Source OnDeselect Declaration public UnityEvent OnDeselect Field Value Type Description UnityEvent | Improve this Doc View Source OnGrabbed Declaration public UnityEvent OnGrabbed Field Value Type Description UnityEvent | Improve this Doc View Source OnInteraction Declaration public UnityEvent OnInteraction Field Value Type Description UnityEvent | Improve this Doc View Source OnReleased Declaration public UnityEvent OnReleased Field Value Type Description UnityEvent | Improve this Doc View Source OnSelect Declaration public UnityEvent OnSelect Field Value Type Description UnityEvent | Improve this Doc View Source pivotOffsetPosition Offset of the pivot point. Use this, if the given pivot point by the model is weird. Declaration public Vector3 pivotOffsetPosition Field Value Type Description Vector3 Default is (0, 0, 0). | Improve this Doc View Source pivotOffsetRotation Offset of the pivot rotation. Use this, if the given pivot point by the model is weird. Declaration public Vector3 pivotOffsetRotation Field Value Type Description Vector3 Default is (0, 0, 0). | Improve this Doc View Source TrainARObjectDisabled If true the object is not selectable, grabbable, interactable, combineable but might be visible. Declaration public bool TrainARObjectDisabled Field Value Type Description Boolean Default is false. Methods | Improve this Doc View Source Combine(String, GameObject) Sends a request to the statemachine to check if this combine was valid. If so, the combine event of this TrainARObject is invoked otherwise the error event is invoked instead. This does NOT physically combine the object, which has to be handled by hand or e.g. the TrainAR Object helper in the visual scripting. Declaration public void Combine(string combinedWithName, GameObject intersectedObject) Parameters Type Name Description String combinedWithName GameObject intersectedObject | Improve this Doc View Source Deselect() Invokes the Deselect event of this TrainARObject and sets it's isSelected bool accordingly. Declaration public void Deselect() | Improve this Doc View Source DisableTrainARObject() Disables interactions with this TrainARObject by disabling it's colliders and Mesh Renderer. Declaration public void DisableTrainARObject() | Improve this Doc View Source EnableTrainARObject() Enables interactions with this TrainARObject by disabling it's colliders and Mesh Renderer. Declaration public void EnableTrainARObject() | Improve this Doc View Source Error() Invokes the error event of this TrainARObject. Declaration public void Error() | Improve this Doc View Source Grab() Sends a request to the statemachine to check if this grab was valid. If so, the grab event of this TrainARObject is invoked otherwise the error event is invoked instead. This does NOT grab the object, which is handled in the InteractionController Declaration public bool Grab() Returns Type Description Boolean | Improve this Doc View Source Interact(String) Sends a request to the statemachine to check if this interaction was valid. If so, the interact event of this TrainARObject is invoked otherwise the error event is invoked instead. Declaration public void Interact(string parameter = \" \") Parameters Type Name Description String parameter A string parameter which is passed to the statemachine. | Improve this Doc View Source Release() Invokes the Release event of this TrainARObject and sets it's isGrabbed bool accordingly. This does NOT release the object, which is handled in the InteractionController Declaration public void Release() | Improve this Doc View Source Select() Invokes the select event of this TrainARObject and sets it's isSelected bool accordingly. Declaration public void Select()"
  },
  "api/Others.ApplicationRuntimeManager.html": {
    "href": "api/Others.ApplicationRuntimeManager.html",
    "title": "Class ApplicationRuntimeManager | TrainAR Documentation",
    "keywords": "Class ApplicationRuntimeManager The ApplicationRuntimeManager handles the TrainAR menu lifecycle. It start and quits Trainings and Application. Inheritance Object ApplicationRuntimeManager Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class ApplicationRuntimeManager : MonoBehaviour Methods | Improve this Doc View Source QuitApplication() Quits the whole Application When in Editor, just stops the preview Declaration public void QuitApplication() | Improve this Doc View Source StartTraining(Int32) Starts a Training with the provided ID Declaration public void StartTraining(int trainingID) Parameters Type Name Description Int32 trainingID"
  },
  "api/Others.ARSessionIsReady.html": {
    "href": "api/Others.ARSessionIsReady.html",
    "title": "Class ARSessionIsReady | TrainAR Documentation",
    "keywords": "Class ARSessionIsReady Detects if the ARSession is loaded and deactivates the loading screen. Inheritance Object ARSessionIsReady Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class ARSessionIsReady : MonoBehaviour"
  },
  "api/Others.html": {
    "href": "api/Others.html",
    "title": "Namespace Others | TrainAR Documentation",
    "keywords": "Namespace Others Classes ApplicationRuntimeManager The ApplicationRuntimeManager handles the TrainAR menu lifecycle. It start and quits Trainings and Application. ARSessionIsReady Detects if the ARSession is loaded and deactivates the loading screen. LeaveAndResetARScene Adds basic functionality like leave and reset application and scenarios. MeshCombiner The MeshCombiner is a utility class used by ConvertToTrainARObject to combine and simplify meshes before converting them into TrainAR objects and computing their outlines and adding behaviours. ObjectInsideCollider Detects collisions of the object it is attached to with other objects to enable combination. PrefabSpawningController Handles the initial spawning and positioning as well as the repositioning of the training assembly. ScenarioCompleted Handles the completion overlay that is shown at the end of the training. SelectionBase Editor utility script that is attached on TrainAR object conversion. With this, authors always select this object when a child is selected in the Scene view. StartARScene Starts the ARScene after the tutorial is finished. StateRequestSimulator Developer Utility. The StateRequestSimulator allows to test the visual scripting stateflows in the editor by simulating requests to the statemachine manually. This is attached to the framework but not active by default. To use it, the PlayModeButtonOverride has to be deactivated/deleted so the playmode can be entered. The StateRequestSimulator is attached to the root object of the TrainAR framework and can then be used in the Hierarchy."
  },
  "api/Others.LeaveAndResetARScene.html": {
    "href": "api/Others.LeaveAndResetARScene.html",
    "title": "Class LeaveAndResetARScene | TrainAR Documentation",
    "keywords": "Class LeaveAndResetARScene Adds basic functionality like leave and reset application and scenarios. Inheritance Object LeaveAndResetARScene Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class LeaveAndResetARScene : MonoBehaviour Methods | Improve this Doc View Source LeaveAndReset() Resets the static variables and returns to the main menu scene. Declaration public void LeaveAndReset() | Improve this Doc View Source QuitApplication() Closes the application. Declaration public void QuitApplication()"
  },
  "api/Others.MeshCombiner.html": {
    "href": "api/Others.MeshCombiner.html",
    "title": "Class MeshCombiner | TrainAR Documentation",
    "keywords": "Class MeshCombiner The MeshCombiner is a utility class used by ConvertToTrainARObject to combine and simplify meshes before converting them into TrainAR objects and computing their outlines and adding behaviours. Inheritance Object MeshCombiner Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class MeshCombiner : MonoBehaviour Properties | Improve this Doc View Source CombineInactiveChildren Declaration public bool CombineInactiveChildren { get; set; } Property Value Type Description Boolean | Improve this Doc View Source CreateMultiMaterialMesh Declaration public bool CreateMultiMaterialMesh { get; set; } Property Value Type Description Boolean | Improve this Doc View Source DeactivateCombinedChildren Declaration public bool DeactivateCombinedChildren { get; set; } Property Value Type Description Boolean | Improve this Doc View Source DeactivateCombinedChildrenMeshRenderers Declaration public bool DeactivateCombinedChildrenMeshRenderers { get; set; } Property Value Type Description Boolean | Improve this Doc View Source DestroyCombinedChildren Declaration public bool DestroyCombinedChildren { get; set; } Property Value Type Description Boolean | Improve this Doc View Source FolderPath Declaration public string FolderPath { get; set; } Property Value Type Description String | Improve this Doc View Source GenerateUVMap Declaration public bool GenerateUVMap { get; set; } Property Value Type Description Boolean Methods | Improve this Doc View Source CombineMeshes(Boolean) Combine children's Meshes into one Mesh. Set 'showCreatedMeshInfo' to true if want to show info about created Mesh in the console. Declaration public void CombineMeshes(bool showCreatedMeshInfo) Parameters Type Name Description Boolean showCreatedMeshInfo"
  },
  "api/Others.ObjectInsideCollider.html": {
    "href": "api/Others.ObjectInsideCollider.html",
    "title": "Class ObjectInsideCollider | TrainAR Documentation",
    "keywords": "Class ObjectInsideCollider Detects collisions of the object it is attached to with other objects to enable combination. Inheritance Object ObjectInsideCollider Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class ObjectInsideCollider : MonoBehaviour Fields | Improve this Doc View Source combinedWithName Temporary store of the name of the collided object. Declaration public string combinedWithName Field Value Type Description String"
  },
  "api/Others.PrefabSpawningController.html": {
    "href": "api/Others.PrefabSpawningController.html",
    "title": "Class PrefabSpawningController | TrainAR Documentation",
    "keywords": "Class PrefabSpawningController Handles the initial spawning and positioning as well as the repositioning of the training assembly. Inheritance Object PrefabSpawningController Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class PrefabSpawningController : MonoBehaviour Fields | Improve this Doc View Source instantiatedPrefab Reference to the spawned training assembly. Declaration public static GameObject instantiatedPrefab Field Value Type Description GameObject Gets created on runtime. | Improve this Doc View Source objectWasSpawned Is the prefab spawned? Declaration public bool objectWasSpawned Field Value Type Description Boolean True if spawned. | Improve this Doc View Source placementPoseIsValid Is the attempted placement pose valid? Declaration public bool placementPoseIsValid Field Value Type Description Boolean True if valid. Methods | Improve this Doc View Source GetSpawnedObject() Returns the instantiated prefab. Declaration public GameObject GetSpawnedObject() Returns Type Description GameObject The instantiated prefab. | Improve this Doc View Source Reposition() Restarts the positioning process to make reposition of the prefab possible. Declaration public void Reposition() Events | Improve this Doc View Source prefabSpawned Event that is triggered after the assembly is spawned. Declaration public static event Action prefabSpawned Event Type Type Description Action | Improve this Doc View Source RepositionPrefab Event that is triggered after repositioning of the training assembly. Declaration public static event Action RepositionPrefab Event Type Type Description Action"
  },
  "api/Others.ScenarioCompleted.html": {
    "href": "api/Others.ScenarioCompleted.html",
    "title": "Class ScenarioCompleted | TrainAR Documentation",
    "keywords": "Class ScenarioCompleted Handles the completion overlay that is shown at the end of the training. Inheritance Object ScenarioCompleted Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class ScenarioCompleted : MonoBehaviour"
  },
  "api/Others.SelectionBase.html": {
    "href": "api/Others.SelectionBase.html",
    "title": "Class SelectionBase | TrainAR Documentation",
    "keywords": "Class SelectionBase Editor utility script that is attached on TrainAR object conversion. With this, authors always select this object when a child is selected in the Scene view. Inheritance Object SelectionBase Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class SelectionBase : MonoBehaviour"
  },
  "api/Others.StartARScene.html": {
    "href": "api/Others.StartARScene.html",
    "title": "Class StartARScene | TrainAR Documentation",
    "keywords": "Class StartARScene Starts the ARScene after the tutorial is finished. Inheritance Object StartARScene Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class StartARScene : MonoBehaviour Methods | Improve this Doc View Source LoadArScene() Loads the (main) AR scene Declaration public void LoadArScene() | Improve this Doc View Source QuitApplication() Closes the Application. Declaration public void QuitApplication()"
  },
  "api/Others.StateRequestSimulator.html": {
    "href": "api/Others.StateRequestSimulator.html",
    "title": "Class StateRequestSimulator | TrainAR Documentation",
    "keywords": "Class StateRequestSimulator Developer Utility. The StateRequestSimulator allows to test the visual scripting stateflows in the editor by simulating requests to the statemachine manually. This is attached to the framework but not active by default. To use it, the PlayModeButtonOverride has to be deactivated/deleted so the playmode can be entered. The StateRequestSimulator is attached to the root object of the TrainAR framework and can then be used in the Hierarchy. Inheritance Object StateRequestSimulator Namespace : Others Assembly : Assembly-CSharp.dll Syntax public class StateRequestSimulator : MonoBehaviour Fields | Improve this Doc View Source interactionType What kind of interaction should be requested. Declaration public InteractionType interactionType Field Value Type Description InteractionType Default is Interact. | Improve this Doc View Source parameter What parameter should be requested. Declaration public string parameter Field Value Type Description String Default is \"\". | Improve this Doc View Source primaryObjectName What is the TrainAR object name of the first object. Declaration public string primaryObjectName Field Value Type Description String Default is \"\". | Improve this Doc View Source secondaryObjectName What is the TrainAR object name of the second object. Declaration public string secondaryObjectName Field Value Type Description String Default is \"\"."
  },
  "api/Static.CustomAction.html": {
    "href": "api/Static.CustomAction.html",
    "title": "Class CustomAction | TrainAR Documentation",
    "keywords": "Class CustomAction Custom actions are actions triggered by events outside of Interacting or combining (e.g. UI quizes) and can send parameters that are then checked against the statemachine. This class is also what authors can use to trigger actions beyond the scope of TrainAR and can be handled by the statemachine by using the Action Node and the \"Custom Action\" type. CustomAction can either be triggered form the instantiated or static context. Inheritance Object CustomAction Namespace : Static Assembly : Assembly-CSharp.dll Syntax public class CustomAction : MonoBehaviour Methods | Improve this Doc View Source DynamicTrigger(String) Triggers a CustomAction with the given parameter. Declaration public void DynamicTrigger(string parameter) Parameters Type Name Description String parameter The parameter to be checked against the statemachine. | Improve this Doc View Source StaticTrigger(String) Triggers a CustomAction with the given parameter from a static context. Declaration public static bool StaticTrigger(string parameter) Parameters Type Name Description String parameter The parameter to be checked against the statemachine. Returns Type Description Boolean Whether this was a correct statechange and triggered to statemachine to proceed."
  },
  "api/Static.html": {
    "href": "api/Static.html",
    "title": "Namespace Static | TrainAR Documentation",
    "keywords": "Namespace Static Classes CustomAction Custom actions are actions triggered by events outside of Interacting or combining (e.g. UI quizes) and can send parameters that are then checked against the statemachine. This class is also what authors can use to trigger actions beyond the scope of TrainAR and can be handled by the statemachine by using the Action Node and the \"Custom Action\" type. CustomAction can either be triggered form the instantiated or static context. StatemachineConnector The StatemachineConnector connects interaction inputs with the visual scripting flow and outputs with the instruction, error and insight controller through events. It therefore functions as a funnel between the Visual Statemachine and the rest of the logic. Either the visual statemachien decides whether actions are correct or wrong (default) or the connection can also be commented out and the decisions on wrong/correct actions can be made manually in the RequestStateChange method by using C# programming. Structs StateInformation The StateInformation is a struct created for state change requests. It holds the information of the request to the statemachine. Enums InteractionType The type of interaction that is used in a StateInformation struct through a state change request."
  },
  "api/Static.InteractionType.html": {
    "href": "api/Static.InteractionType.html",
    "title": "Enum InteractionType | TrainAR Documentation",
    "keywords": "Enum InteractionType The type of interaction that is used in a StateInformation struct through a state change request. Namespace : Static Assembly : Assembly-CSharp.dll Syntax public enum InteractionType Fields Name Description Combine Custom Deselect Grab Interact Release Select"
  },
  "api/Static.StateInformation.html": {
    "href": "api/Static.StateInformation.html",
    "title": "Struct StateInformation | TrainAR Documentation",
    "keywords": "Struct StateInformation The StateInformation is a struct created for state change requests. It holds the information of the request to the statemachine. Namespace : Static Assembly : Assembly-CSharp.dll Syntax public struct StateInformation Constructors | Improve this Doc View Source StateInformation(String, String, InteractionType, String, GameObject, GameObject) Constructor of the StateInformation struct. Declaration public StateInformation(string primaryObjectName = \"\", string secondaryObjectName = \"\", InteractionType interactionType = InteractionType.Custom, string parameter = \" \", GameObject firstGameObject = null, GameObject secondGameObject = null) Parameters Type Name Description String primaryObjectName String secondaryObjectName InteractionType interactionType String parameter GameObject firstGameObject GameObject secondGameObject Fields | Improve this Doc View Source firstGameObject The primary GameObject request of this request. Declaration public GameObject firstGameObject Field Value Type Description GameObject | Improve this Doc View Source interactionType The type of interaction that is requested. Declaration public InteractionType interactionType Field Value Type Description InteractionType | Improve this Doc View Source parameter The parameter that is passed with the request. E.g. for custom actions or questionnaires this can also be the only thing that is checked against by the statemachine. Declaration public string parameter Field Value Type Description String | Improve this Doc View Source primaryObjectName The primary object of this request. Declaration public string primaryObjectName Field Value Type Description String | Improve this Doc View Source secondaryObjectName The secondary object of this request (e.g. for a combination, the object that is not grabbed) Declaration public string secondaryObjectName Field Value Type Description String | Improve this Doc View Source secondGameObject The secondary GameObject request of this request. Declaration public GameObject secondGameObject Field Value Type Description GameObject"
  },
  "api/Static.StatemachineConnector.html": {
    "href": "api/Static.StatemachineConnector.html",
    "title": "Class StatemachineConnector | TrainAR Documentation",
    "keywords": "Class StatemachineConnector The StatemachineConnector connects interaction inputs with the visual scripting flow and outputs with the instruction, error and insight controller through events. It therefore functions as a funnel between the Visual Statemachine and the rest of the logic. Either the visual statemachien decides whether actions are correct or wrong (default) or the connection can also be commented out and the decisions on wrong/correct actions can be made manually in the RequestStateChange method by using C# programming. Inheritance Object StatemachineConnector Namespace : Static Assembly : Assembly-CSharp.dll Syntax public class StatemachineConnector Fields | Improve this Doc View Source errorCounter The amount of errors performed by the user of the training. Declaration public int errorCounter Field Value Type Description Int32 | Improve this Doc View Source Instance The static instance of this StatemachineConnector. Declaration public static StatemachineConnector Instance Field Value Type Description StatemachineConnector Methods | Improve this Doc View Source AcceptedStateChange(Boolean) Called by the state machine. Triggers an Action that indicates if the state change was accepted. Declaration public void AcceptedStateChange(bool stateChangeAccepted) Parameters Type Name Description Boolean stateChangeAccepted Is the statechange accepted | Improve this Doc View Source RegisterNewStateChangeTrigger(Func<StateInformation, Boolean>) Registers a new state change trigger from the visual state flow. This trigger determines which node in the visual scripting graph is handling the state change request. Declaration public static void RegisterNewStateChangeTrigger(Func<StateInformation, bool> action) Parameters Type Name Description Func < StateInformation , Boolean > action The Func to that is registered. | Improve this Doc View Source RequestStateChange(StateInformation) Request a statechange from the statemachine. Declaration public bool RequestStateChange(StateInformation stateInformation) Parameters Type Name Description StateInformation stateInformation Returns Type Description Boolean | Improve this Doc View Source Reset() Resets the instance of this static instance. Declaration public void Reset() | Improve this Doc View Source ShowCompletionOverlay() Triggers the scenario completion overlay. Declaration public void ShowCompletionOverlay() | Improve this Doc View Source ShowErrorOverlay(String, String) Called by the visual state machine. Triggers an Action that shows the error overlay. Declaration public void ShowErrorOverlay(string headerText, string errorText) Parameters Type Name Description String headerText The Header of the error overlay String errorText The text body of the error overlay | Improve this Doc View Source ShowExpertInsights(AudioClip, Sprite, String) Called by the visual state machine. Triggers an Action that shows the expert insight modality and plays and audio clip. Declaration public void ShowExpertInsights(AudioClip audio, Sprite image, string text) Parameters Type Name Description AudioClip audio The audioclip that is played with the expert insight Sprite image The image that is displayed, e.g. the expert providing the insight. String text The text displayed at the expert speechbubble | Improve this Doc View Source StartQuestionUI(QuestionnaireController.QuestionUITypes, String, List<QuestionnaireController.Answer>) Triggers a new Questionnaire to be answered by the user on the UI. Declaration public void StartQuestionUI(QuestionnaireController.QuestionUITypes type, string question, List<QuestionnaireController.Answer> answers) Parameters Type Name Description QuestionnaireController.QuestionUITypes type The type of Question(MultipleChoice, List, Input). String question The question. List < QuestionnaireController.Answer > answers A List of struct with all possible answers. | Improve this Doc View Source UpdateTopPanel(String, Int32) Called by the visual state machine, triggers an Action that updates the instruction text and completion percentage of the top panel. Declaration public void UpdateTopPanel(string text, int completionPercentage) Parameters Type Name Description String text New instruction displayed on the top panel Int32 completionPercentage New compeltion percentage displayed Events | Improve this Doc View Source TriggerAcceptedStateChange Declaration public event Action<bool> TriggerAcceptedStateChange Event Type Type Description Action < Boolean > | Improve this Doc View Source TriggerErrorOverlay Declaration public event Action<string, string> TriggerErrorOverlay Event Type Type Description Action < String , String > | Improve this Doc View Source TriggerExpertInsights Declaration public event Action<AudioClip, Sprite, string> TriggerExpertInsights Event Type Type Description Action < AudioClip , Sprite , String > | Improve this Doc View Source TriggerScenarioCompletionOverlay Declaration public event Action TriggerScenarioCompletionOverlay Event Type Type Description Action | Improve this Doc View Source TriggerTopPanelChange Declaration public event Action<string, int> TriggerTopPanelChange Event Type Type Description Action < String , Int32 > | Improve this Doc View Source TriggerUIQuestion Declaration public event Action<QuestionnaireController.QuestionUITypes, string, List<QuestionnaireController.Answer>> TriggerUIQuestion Event Type Type Description Action < QuestionnaireController.QuestionUITypes , String , List < QuestionnaireController.Answer >>"
  },
  "api/Tracking.FetchAspectRatioFromARCamera.html": {
    "href": "api/Tracking.FetchAspectRatioFromARCamera.html",
    "title": "Class FetchAspectRatioFromARCamera | TrainAR Documentation",
    "keywords": "Class FetchAspectRatioFromARCamera Fetches the projectionmatrix from one camera and diretly applies it to another one. Inheritance Object FetchAspectRatioFromARCamera Namespace : Tracking Assembly : Assembly-CSharp.dll Syntax public class FetchAspectRatioFromARCamera : MonoBehaviour"
  },
  "api/Tracking.html": {
    "href": "api/Tracking.html",
    "title": "Namespace Tracking | TrainAR Documentation",
    "keywords": "Namespace Tracking Classes FetchAspectRatioFromARCamera Fetches the projectionmatrix from one camera and diretly applies it to another one."
  },
  "api/UI.CrosshairOnOff.html": {
    "href": "api/UI.CrosshairOnOff.html",
    "title": "Class CrosshairOnOff | TrainAR Documentation",
    "keywords": "Class CrosshairOnOff Controls the dynamic transformations of the crosshair. It activates and deactivates the crosshair but also visualizes the distance to a grabbable TrainAR object by converging the crosshairs size until the object would be selected (e.g. if the user is too far away from an object to grab it). Inheritance Object CrosshairOnOff Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class CrosshairOnOff : MonoBehaviour"
  },
  "api/UI.DirectInfoController.html": {
    "href": "api/UI.DirectInfoController.html",
    "title": "Class DirectInfoController | TrainAR Documentation",
    "keywords": "Class DirectInfoController The DirectInfoBoxController handles the displaying of direct info boxes that are used to display insishgts to the user. It is triggerd through invocation of an action in the StatemachineConnector and therefore has no public methods. Inheritance Object DirectInfoController Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class DirectInfoController : MonoBehaviour"
  },
  "api/UI.ErrorOverlayController.html": {
    "href": "api/UI.ErrorOverlayController.html",
    "title": "Class ErrorOverlayController | TrainAR Documentation",
    "keywords": "Class ErrorOverlayController The error overlay controller handles the error overlay, triggers it on actions from the statemachine and sets its texts. It is triggerd through invocation of an action in the StatemachineConnector and therefore has no public methods. Inheritance Object ErrorOverlayController Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class ErrorOverlayController : MonoBehaviour"
  },
  "api/UI.html": {
    "href": "api/UI.html",
    "title": "Namespace UI | TrainAR Documentation",
    "keywords": "Namespace UI Classes CrosshairOnOff Controls the dynamic transformations of the crosshair. It activates and deactivates the crosshair but also visualizes the distance to a grabbable TrainAR object by converging the crosshairs size until the object would be selected (e.g. if the user is too far away from an object to grab it). DirectInfoController The DirectInfoBoxController handles the displaying of direct info boxes that are used to display insishgts to the user. It is triggerd through invocation of an action in the StatemachineConnector and therefore has no public methods. ErrorOverlayController The error overlay controller handles the error overlay, triggers it on actions from the statemachine and sets its texts. It is triggerd through invocation of an action in the StatemachineConnector and therefore has no public methods. InputFieldAdjust InputFieldAdjust Adjusts the UI of the Input field when the keyboard is opened. This is mostly problematic on Android otherwise. InteractButton Handles interactions with the interact button. InteractionButtonController Handles the behaviour of the interaction buttons, such as enabling and disabling when appropriate or highlighting the combine button in orange when a combination would be possible. It also allows for grabbed objects to be rotatable. OnBoardingController The OnBoardingController handles displaying the onboarding animations for scanning the environment and placing the training assembly by automaticaly detecting at which point and where sufficient feature points for a plane were detected. OpenSidePanel Handles opening or closing of the side panel (burger menu) wiht options for help, quitting and replacing the assembly. Question The abstract class for questions to share the same UI functions. QuestionnaireController The QuestionaireController provides the functionality to control the input field questions, reqular question and question lists. The input field question opens the keyboard and recives any given string input from the user. The regular question opens a question with up to four possible pre-defined awnsers. The question list opens a list with n possible items and continues when all right items were selected. SaveArea The SafeArea scripts moves UI components when they would otherwise be occluded by e.g. cutout cameras or speakers on some newer smartphone devices. StreamVideo StreamVideo is a wrapper for the Videoplayer class and handles playing of the onboarding animations. TopPanelController The TopPanelController handpes updates to the UI panel of the trainign scenario, showing the instructions and progress percentage of the training. Structs QuestionnaireController.Answer Holder for information for one answer. Enums QuestionnaireController.QuestionUITypes The type of the UI custom action/question."
  },
  "api/UI.InputFieldAdjust.html": {
    "href": "api/UI.InputFieldAdjust.html",
    "title": "Class InputFieldAdjust | TrainAR Documentation",
    "keywords": "Class InputFieldAdjust InputFieldAdjust Adjusts the UI of the Input field when the keyboard is opened. This is mostly problematic on Android otherwise. Inheritance Object InputFieldAdjust Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class InputFieldAdjust : MonoBehaviour Methods | Improve this Doc View Source AdjustInputFieldPosition() Adjusts the position of the Inputfield UI when the Android or iOS keyboard is opened. Declaration public void AdjustInputFieldPosition()"
  },
  "api/UI.InteractButton.html": {
    "href": "api/UI.InteractButton.html",
    "title": "Class InteractButton | TrainAR Documentation",
    "keywords": "Class InteractButton Handles interactions with the interact button. Inheritance Object InteractButton Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class InteractButton : MonoBehaviour Methods | Improve this Doc View Source ReleaseInteract() Calls either an interact or an combine, depending on the interactioncontroller context. Declaration public void ReleaseInteract()"
  },
  "api/UI.InteractionButtonController.html": {
    "href": "api/UI.InteractionButtonController.html",
    "title": "Class InteractionButtonController | TrainAR Documentation",
    "keywords": "Class InteractionButtonController Handles the behaviour of the interaction buttons, such as enabling and disabling when appropriate or highlighting the combine button in orange when a combination would be possible. It also allows for grabbed objects to be rotatable. Inheritance Object InteractionButtonController Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class InteractionButtonController : MonoBehaviour Fields | Improve this Doc View Source grabbedObjectRotationSpeed The speed that a grabbed object is rotated. Declaration public float grabbedObjectRotationSpeed Field Value Type Description Single Default is 0.2f. Methods | Improve this Doc View Source ActivateInteractButtons() Activates the interaction buttons for the user to see. Declaration public void ActivateInteractButtons() | Improve this Doc View Source DeactivateInteractButtons() Deactivates the interaction buttons. Declaration public void DeactivateInteractButtons() | Improve this Doc View Source GrabRelease() Handles what happenes when the grab/Release button is called depending on its current state. Declaration public void GrabRelease()"
  },
  "api/UI.OnBoardingController.html": {
    "href": "api/UI.OnBoardingController.html",
    "title": "Class OnBoardingController | TrainAR Documentation",
    "keywords": "Class OnBoardingController The OnBoardingController handles displaying the onboarding animations for scanning the environment and placing the training assembly by automaticaly detecting at which point and where sufficient feature points for a plane were detected. Inheritance Object OnBoardingController Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class OnBoardingController : MonoBehaviour"
  },
  "api/UI.OpenSidePanel.html": {
    "href": "api/UI.OpenSidePanel.html",
    "title": "Class OpenSidePanel | TrainAR Documentation",
    "keywords": "Class OpenSidePanel Handles opening or closing of the side panel (burger menu) wiht options for help, quitting and replacing the assembly. Inheritance Object OpenSidePanel Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class OpenSidePanel : MonoBehaviour Methods | Improve this Doc View Source TogglePanel() Opens or closes the Panel. Declaration public void TogglePanel()"
  },
  "api/UI.Question.html": {
    "href": "api/UI.Question.html",
    "title": "Class Question | TrainAR Documentation",
    "keywords": "Class Question The abstract class for questions to share the same UI functions. Inheritance Object Question Namespace : UI Assembly : Assembly-CSharp.dll Syntax public abstract class Question Fields | Improve this Doc View Source questionText Every question needs a questionText. Declaration public string questionText Field Value Type Description String"
  },
  "api/UI.QuestionnaireController.Answer.html": {
    "href": "api/UI.QuestionnaireController.Answer.html",
    "title": "Struct QuestionnaireController.Answer | TrainAR Documentation",
    "keywords": "Struct QuestionnaireController.Answer Holder for information for one answer. Namespace : UI Assembly : Assembly-CSharp.dll Syntax public struct Answer Constructors | Improve this Doc View Source Answer(String, String, Boolean) Constructor for Answers. Declaration public Answer(string answer, string answerFeedback, bool answerCorrect) Parameters Type Name Description String answer Text of the answer. String answerFeedback Text for feedback when the answer was taken. Boolean answerCorrect True if the answer is right. Fields | Improve this Doc View Source answer Text of the answer. Declaration public string answer Field Value Type Description String Set by constructor. | Improve this Doc View Source answerCorrect Is this answer right or wrong. Declaration public bool answerCorrect Field Value Type Description Boolean Set by constructor. | Improve this Doc View Source answerFeedback Text of the feedback. Declaration public string answerFeedback Field Value Type Description String Set by constructor."
  },
  "api/UI.QuestionnaireController.html": {
    "href": "api/UI.QuestionnaireController.html",
    "title": "Class QuestionnaireController | TrainAR Documentation",
    "keywords": "Class QuestionnaireController The QuestionaireController provides the functionality to control the input field questions, reqular question and question lists. The input field question opens the keyboard and recives any given string input from the user. The regular question opens a question with up to four possible pre-defined awnsers. The question list opens a list with n possible items and continues when all right items were selected. Inheritance Object QuestionnaireController Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class QuestionnaireController : MonoBehaviour Fields | Improve this Doc View Source ButtonBlueprint Reference to the AnswerButtonPrefab. Declaration public Button ButtonBlueprint Field Value Type Description Button Set in inspector. | Improve this Doc View Source buttons References to the Buttons Declaration public List<Button> buttons Field Value Type Description List < Button > Set in inspector. | Improve this Doc View Source correctAnswerColor Color for correct answers. Declaration public Color correctAnswerColor Field Value Type Description Color Default set in inspector. | Improve this Doc View Source correctAnswerSound Audioclip that is played when correct answer is pressed. Declaration public AudioClip correctAnswerSound Field Value Type Description AudioClip Default is set in inspector. | Improve this Doc View Source defaultUIColor Color for unpressed buttons. Declaration public Color defaultUIColor Field Value Type Description Color Default set in inspector. | Improve this Doc View Source duration How long it takes to fade in the UI. Declaration public float duration Field Value Type Description Single Default is 1.0f seconds. | Improve this Doc View Source inputFieldAnswerText Reference to the inputFieldAnswerText. Declaration public TextMeshProUGUI inputFieldAnswerText Field Value Type Description TextMeshProUGUI Set in inspector. | Improve this Doc View Source inputFieldQuestionText Reference to the inputFieldQuestionText. Declaration public TextMeshProUGUI inputFieldQuestionText Field Value Type Description TextMeshProUGUI Set in inspector. | Improve this Doc View Source inputFieldQuestionUI Reference to the root gameObject of the inputFieldUI. Declaration public GameObject inputFieldQuestionUI Field Value Type Description GameObject Set in inspector. | Improve this Doc View Source questionList Reference to the root of the question list UI. Declaration public GameObject questionList Field Value Type Description GameObject Set in inspector. | Improve this Doc View Source questionListQuestionText Reference to the QuestionListText. Declaration public TextMeshProUGUI questionListQuestionText Field Value Type Description TextMeshProUGUI Set in inspector. | Improve this Doc View Source questionnaireUIRectTransform Reference to the UIRectTransform. Declaration public RectTransform questionnaireUIRectTransform Field Value Type Description RectTransform Set in inspector. | Improve this Doc View Source questionText Reference to the questionText. Declaration public TextMeshProUGUI questionText Field Value Type Description TextMeshProUGUI Set in inspector. | Improve this Doc View Source questionTextUI Reference to the questionText. Declaration public GameObject questionTextUI Field Value Type Description GameObject Set in inspector. | Improve this Doc View Source regularQuestionUI Reference to the root gameObject of the regularQuestionUI. Declaration public GameObject regularQuestionUI Field Value Type Description GameObject Set in inspector. | Improve this Doc View Source responseText Reference to the ResponseText. Declaration public GameObject responseText Field Value Type Description GameObject Set in inspector. | Improve this Doc View Source rightAnswer Stores right answers for endscreen UI. Declaration public List<string> rightAnswer Field Value Type Description List < String > Set on runtime. | Improve this Doc View Source wrongAnswerColor Color for wrong answers. Declaration public Color wrongAnswerColor Field Value Type Description Color Default set in inspector. | Improve this Doc View Source wrongAnsweredQuestions Stores wrong answered questions for endscreen UI. Declaration public List<string> wrongAnsweredQuestions Field Value Type Description List < String > Set on runtime. | Improve this Doc View Source wrongAnswers Stores wrong answers for endscreen UI. Declaration public List<string> wrongAnswers Field Value Type Description List < String > Set on runtime. | Improve this Doc View Source wrongAnswerSound Audioclip that is played when wrong answer is pressed. Declaration public AudioClip wrongAnswerSound Field Value Type Description AudioClip Default is set in inspector. Methods | Improve this Doc View Source ContinueButtonOnClick() Get's called when the continue button is pressed. When the chosen answer was correct, the statemachine gets notified. When the chosen answer was wrong, the question gets displayed again. Declaration public void ContinueButtonOnClick() | Improve this Doc View Source InitInputfield(String) Open the inputField question UI. Declaration public void InitInputfield(string question) Parameters Type Name Description String question Text of the question. | Improve this Doc View Source InitQuestion(String, List<QuestionnaireController.Answer>) Open the regular question UI. Declaration public void InitQuestion(string question, List<QuestionnaireController.Answer> answers) Parameters Type Name Description String question Text of the question. List < QuestionnaireController.Answer > answers List of all possible answers. | Improve this Doc View Source InitQuestionList(String, List<QuestionnaireController.Answer>) Open the questionList UI. Declaration public void InitQuestionList(string question, List<QuestionnaireController.Answer> answers) Parameters Type Name Description String question Text of the question. List < QuestionnaireController.Answer > answers List of all possbile answers. | Improve this Doc View Source NotifyStatemachine(String, QuestionnaireController.QuestionUITypes) Notify the statemachine with the result of the question UI. Declaration public void NotifyStatemachine(string value, QuestionnaireController.QuestionUITypes type = QuestionnaireController.QuestionUITypes.Question) Parameters Type Name Description String value Result in text form. QuestionnaireController.QuestionUITypes type Type of question. | Improve this Doc View Source QuestionInputValidate() Validate if given input of the inputQuestion UI was correct. Declaration public void QuestionInputValidate()"
  },
  "api/UI.QuestionnaireController.QuestionUITypes.html": {
    "href": "api/UI.QuestionnaireController.QuestionUITypes.html",
    "title": "Enum QuestionnaireController.QuestionUITypes | TrainAR Documentation",
    "keywords": "Enum QuestionnaireController.QuestionUITypes The type of the UI custom action/question. Namespace : UI Assembly : Assembly-CSharp.dll Syntax public enum QuestionUITypes Fields Name Description InputQuestion Question QuestionList"
  },
  "api/UI.SaveArea.html": {
    "href": "api/UI.SaveArea.html",
    "title": "Class SaveArea | TrainAR Documentation",
    "keywords": "Class SaveArea The SafeArea scripts moves UI components when they would otherwise be occluded by e.g. cutout cameras or speakers on some newer smartphone devices. Inheritance Object SaveArea Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class SaveArea : MonoBehaviour"
  },
  "api/UI.StreamVideo.html": {
    "href": "api/UI.StreamVideo.html",
    "title": "Class StreamVideo | TrainAR Documentation",
    "keywords": "Class StreamVideo StreamVideo is a wrapper for the Videoplayer class and handles playing of the onboarding animations. Inheritance Object StreamVideo Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class StreamVideo : MonoBehaviour Methods | Improve this Doc View Source StartVideo() Starts playing the specified video. Declaration public void StartVideo()"
  },
  "api/UI.TopPanelController.html": {
    "href": "api/UI.TopPanelController.html",
    "title": "Class TopPanelController | TrainAR Documentation",
    "keywords": "Class TopPanelController The TopPanelController handpes updates to the UI panel of the trainign scenario, showing the instructions and progress percentage of the training. Inheritance Object TopPanelController Namespace : UI Assembly : Assembly-CSharp.dll Syntax public class TopPanelController : MonoBehaviour Fields | Improve this Doc View Source errorColor Declaration public Color errorColor Field Value Type Description Color | Improve this Doc View Source successColor The color of the UI animation played on correct actions. Declaration public Color successColor Field Value Type Description Color"
  },
  "api/Visual_Scripting.Action.html": {
    "href": "api/Visual_Scripting.Action.html",
    "title": "Class Action | TrainAR Documentation",
    "keywords": "Class Action Implements the \"Interacting\", \"Combining\" and \"Custom\" Action functionality of the TrainAR Framework, therefore it checks if the user triggered the \"Interact\", \"Combine\" Buttons or triggered a CustomAction through scripts and allows to check this against the stored state in the visual statemachine. Inheritance Object Action Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class Action : Unit Fields | Improve this Doc View Source actionChoice What type of actions are accepted by this node. Declaration public Action.TrainARActionChoices actionChoice Field Value Type Description Action.TrainARActionChoices Set in node in the editor. Default is Interaction. Properties | Improve this Doc View Source ARCombinableName1 The Name of the first correct interactable for this step. Declaration public ValueInput ARCombinableName1 { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source ARCombinableName2 The Name of the second correct interactable for this step. Declaration public ValueInput ARCombinableName2 { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source ARInteractableName The Name of the correct interactable for this step. Declaration public ValueInput ARInteractableName { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source CorrectAction The Output port of the Unity that is triggered when the users interaction was CORRECT. Declaration public ControlOutput CorrectAction { get; } Property Value Type Description ControlOutput Set in node in the editor. | Improve this Doc View Source CorrectParameterText The correct parameter for the custom event. Declaration public ValueInput CorrectParameterText { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source graphReference The Graphreference stores the current position in the flow graph to revisit it on Event/Action triggers. Declaration public GraphReference graphReference { get; } Property Value Type Description GraphReference Set in node in the editor. | Improve this Doc View Source IncorrectAction The Output port of the Unity that is triggered when the users interaction was INCORRECT. Declaration public ControlOutput IncorrectAction { get; } Property Value Type Description ControlOutput Set in node in the editor. | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input, output and value ports. Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.Action.TrainARActionChoices.html": {
    "href": "api/Visual_Scripting.Action.TrainARActionChoices.html",
    "title": "Enum Action.TrainARActionChoices | TrainAR Documentation",
    "keywords": "Enum Action.TrainARActionChoices The type of interaction to check against. Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public enum TrainARActionChoices Fields Name Description Combination CustomAction Interaction"
  },
  "api/Visual_Scripting.ActionFork.html": {
    "href": "api/Visual_Scripting.ActionFork.html",
    "title": "Class ActionFork | TrainAR Documentation",
    "keywords": "Class ActionFork Implements the \"Interacting\", \"Combining\" and \"Custom\" Action functionality of the TrainAR Framework, therefore it checks if the user triggered the \"Interact\", \"Combine\" Buttons or triggered a CustomAction through scripts and allows to check this against the stored state in the visual statemachine. This is the fork version of the action node. Therefore there are multiple correct answers and the stateflow enters a fork depending on which one is selected. Inheritance Object ActionFork Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class ActionFork : Unit Fields | Improve this Doc View Source actionChoice What type of actions are accepted by this node. Declaration public ActionFork.TrainARActionChoices actionChoice Field Value Type Description ActionFork.TrainARActionChoices Set in node in the editor. Default is Interaction. | Improve this Doc View Source actionCount How many actions are in this node. Declaration public int actionCount Field Value Type Description Int32 Set in node in the editor.Default is 1. Properties | Improve this Doc View Source ARCombinableName1s The Name of the first correct interactable for this step. Declaration public List<ValueInput> ARCombinableName1s { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source ARCombinableName2s The Name of the second correct interactable for this step. Declaration public List<ValueInput> ARCombinableName2s { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source ARInteractableNames The Name of the correct interactable for this step. Declaration public List<ValueInput> ARInteractableNames { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source CorrectActions The Output port of the Unity that is triggered when the users interaction was CORRECT. Declaration public List<ControlOutput> CorrectActions { get; } Property Value Type Description List < ControlOutput > Set in node in the editor. | Improve this Doc View Source CorrectParameterTexts The correct parameter for the custom event. Declaration public List<ValueInput> CorrectParameterTexts { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source graphReference The Graphreference stores the current position in the flow graph to revisit it on Event/Action triggers. Declaration public GraphReference graphReference { get; } Property Value Type Description GraphReference Set in node in the editor. | Improve this Doc View Source IncorrectAction The Output port of the Unity that is triggered when the users interaction was INCORRECT. Declaration public ControlOutput IncorrectAction { get; } Property Value Type Description ControlOutput Set in node in the editor. | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input, output and value ports. Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.ActionFork.TrainARActionChoices.html": {
    "href": "api/Visual_Scripting.ActionFork.TrainARActionChoices.html",
    "title": "Enum ActionFork.TrainARActionChoices | TrainAR Documentation",
    "keywords": "Enum ActionFork.TrainARActionChoices The type of interaction to check against. Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public enum TrainARActionChoices Fields Name Description Combination CustomAction Interaction"
  },
  "api/Visual_Scripting.ActionMulti.html": {
    "href": "api/Visual_Scripting.ActionMulti.html",
    "title": "Class ActionMulti | TrainAR Documentation",
    "keywords": "Class ActionMulti Implements the \"Interacting\", \"Combining\" and \"Custom\" Action functionality of the TrainAR Framework, therefore it checks if the user triggered the \"Interact\", \"Combine\" Buttons or triggered a CustomAction through scripts and allows to check this against the stored state in the visual statemachine. This is the multi version of the action node. Therefore all specified actions in this node have to be completed before advancing. Inheritance Object ActionMulti Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class ActionMulti : Unit Fields | Improve this Doc View Source actionChoice What type of actions are accepted by this node. Declaration public ActionMulti.TrainARActionChoices actionChoice Field Value Type Description ActionMulti.TrainARActionChoices Set in node in the editor. Default is Interaction. | Improve this Doc View Source actionCount How many actions are in this node. Declaration public int actionCount Field Value Type Description Int32 Set in node in the editor.Default is 1. Properties | Improve this Doc View Source AllActionsCorrect The Output port of the Unity that is triggered when the users interaction was CORRECT. Declaration public ControlOutput AllActionsCorrect { get; } Property Value Type Description ControlOutput Set in node in the editor. | Improve this Doc View Source ARCombinableName1s The Name of the first correct interactable for this step. Declaration public List<ValueInput> ARCombinableName1s { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source ARCombinableName2s The Name of the second correct interactable for this step. Declaration public List<ValueInput> ARCombinableName2s { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source ARInteractableNames The Name of the correct interactable for this step. Declaration public List<ValueInput> ARInteractableNames { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source CorrectParameterTexts The correct parameter for the custom event. Declaration public List<ValueInput> CorrectParameterTexts { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source graphReference The Graphreference stores the current position in the flow graph to revisit it on Event/Action triggers. Declaration public GraphReference graphReference { get; } Property Value Type Description GraphReference Set in node in the editor. | Improve this Doc View Source IncorrectAction The Output port of the Unity that is triggered when the users interaction was INCORRECT. Declaration public ControlOutput IncorrectAction { get; } Property Value Type Description ControlOutput Set in node in the editor. | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input, output and value ports. Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.ActionMulti.TrainARActionChoices.html": {
    "href": "api/Visual_Scripting.ActionMulti.TrainARActionChoices.html",
    "title": "Enum ActionMulti.TrainARActionChoices | TrainAR Documentation",
    "keywords": "Enum ActionMulti.TrainARActionChoices The type of interaction to check against. Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public enum TrainARActionChoices Fields Name Description Combination CustomAction Interaction"
  },
  "api/Visual_Scripting.ActionUI.html": {
    "href": "api/Visual_Scripting.ActionUI.html",
    "title": "Class ActionUI | TrainAR Documentation",
    "keywords": "Class ActionUI Implements the UI questionnaire functionality of TrainAR, therefore it triggers and checks against UI questions like text input fields, questionnaires, and question lists. Inheritance Object ActionUI Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class ActionUI : Unit Fields | Improve this Doc View Source actionChoice What type of question is triggered by this node. Declaration public ActionUI.TrainARUIActionChoices actionChoice Field Value Type Description ActionUI.TrainARUIActionChoices Set in node in the editor | Improve this Doc View Source correctAnswers The amount of correct answers. Declaration public int correctAnswers Field Value Type Description Int32 Set in node in the editor. Default is 2. | Improve this Doc View Source wrongAnswers The amount of wrong answers. Declaration public int wrongAnswers Field Value Type Description Int32 Set in node in the editor. Default is 2. Properties | Improve this Doc View Source CorrectAction The Output port of the Unity that is triggered when the users interaction was CORRECT. Declaration public List<ControlOutput> CorrectAction { get; } Property Value Type Description List < ControlOutput > Set in node in the editor. | Improve this Doc View Source CorrectAnswers The Texts for the correct answers for this step. Declaration public List<ValueInput> CorrectAnswers { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source CorrectAnswersFeedback The Texts for the correct answers for this step. Declaration public List<ValueInput> CorrectAnswersFeedback { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source graphReference The Graphreference stores the current position in the flow graph to revisit it on Event/Action triggers. Declaration public GraphReference graphReference { get; } Property Value Type Description GraphReference Set in node in the editor. | Improve this Doc View Source IncorrectAction The Output port of the Unity that is triggered when the users interaction was INCORRECT. Declaration public List<ControlOutput> IncorrectAction { get; } Property Value Type Description List < ControlOutput > Set in node in the editor. | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. | Improve this Doc View Source Question The Text for the question for this step. Declaration public ValueInput Question { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source WrongAnswers The Texts for the wrong answers for this step. Declaration public List<ValueInput> WrongAnswers { get; } Property Value Type Description List < ValueInput > Set in node in the editor. | Improve this Doc View Source WrongAnswersFeedback The Texts for the wrong answers for this step. Declaration public List<ValueInput> WrongAnswersFeedback { get; } Property Value Type Description List < ValueInput > Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input, output and value ports Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.ActionUI.TrainARUIActionChoices.html": {
    "href": "api/Visual_Scripting.ActionUI.TrainARUIActionChoices.html",
    "title": "Enum ActionUI.TrainARUIActionChoices | TrainAR Documentation",
    "keywords": "Enum ActionUI.TrainARUIActionChoices The type of UI questionnaire triggered and check against. Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public enum TrainARUIActionChoices Fields Name Description InputField ListSelection Questionnaire"
  },
  "api/Visual_Scripting.Conclusion.html": {
    "href": "api/Visual_Scripting.Conclusion.html",
    "title": "Class Conclusion | TrainAR Documentation",
    "keywords": "Class Conclusion Triggers the Completion overlay that shows the training assessment of the scenario and ends the stateflow/training. Inheritance Object Conclusion Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class Conclusion : Unit Properties | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input and value ports As this terminates the scenario, there is no output port or flow, the rest is handled through the script-based components in the framework. Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.Feedback.html": {
    "href": "api/Visual_Scripting.Feedback.html",
    "title": "Class Feedback | TrainAR Documentation",
    "keywords": "Class Feedback Implements the \"Feedback\" functionality of the TrainAR Framework, therefore it triggers the error overlay modality to show feedback (e.g. for an incorrect important action). Inheritance Object Feedback Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class Feedback : Unit Properties | Improve this Doc View Source ErrorText The Error text that is displayed for the current step. Declaration public ValueInput ErrorText { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source HeaderText The Header text that is displayed for the current step. Declaration public ValueInput HeaderText { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. | Improve this Doc View Source OutputFlow The Output port of the Unit that is tirggered after executing the units logic. Declaration public ControlOutput OutputFlow { get; } Property Value Type Description ControlOutput Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input, output and value ports. Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.html": {
    "href": "api/Visual_Scripting.html",
    "title": "Namespace Visual_Scripting | TrainAR Documentation",
    "keywords": "Namespace Visual_Scripting Classes Action Implements the \"Interacting\", \"Combining\" and \"Custom\" Action functionality of the TrainAR Framework, therefore it checks if the user triggered the \"Interact\", \"Combine\" Buttons or triggered a CustomAction through scripts and allows to check this against the stored state in the visual statemachine. ActionFork Implements the \"Interacting\", \"Combining\" and \"Custom\" Action functionality of the TrainAR Framework, therefore it checks if the user triggered the \"Interact\", \"Combine\" Buttons or triggered a CustomAction through scripts and allows to check this against the stored state in the visual statemachine. This is the fork version of the action node. Therefore there are multiple correct answers and the stateflow enters a fork depending on which one is selected. ActionMulti Implements the \"Interacting\", \"Combining\" and \"Custom\" Action functionality of the TrainAR Framework, therefore it checks if the user triggered the \"Interact\", \"Combine\" Buttons or triggered a CustomAction through scripts and allows to check this against the stored state in the visual statemachine. This is the multi version of the action node. Therefore all specified actions in this node have to be completed before advancing. ActionUI Implements the UI questionnaire functionality of TrainAR, therefore it triggers and checks against UI questions like text input fields, questionnaires, and question lists. Conclusion Triggers the Completion overlay that shows the training assessment of the scenario and ends the stateflow/training. Feedback Implements the \"Feedback\" functionality of the TrainAR Framework, therefore it triggers the error overlay modality to show feedback (e.g. for an incorrect important action). Insights Implements the \"Insights\" functionality of the TrainAR Framework, therefore it triggers the expert input modality to show additional insights and tips and optionally plays audio clips. Instructions Implements the \"Instruction\" functionality of the TrainAR Framework, therefore it updates the isntrutions and progress percentage of the Top panel. ObjectHelper The Object helper provides utility methods to toggle visibility, grabbability, interactability, and combinability of TrainAR objects, to destroy them, to get GameObject references to TrainAR object in the stateflow and many other utility functions. OnboardingSetup Adds an EventHook for the onboarding setup that is used to trigger the start of the visual scripting stateflow after the onboarding was completed. VisualScriptingEventNames Registering a string name for your custom event to hook it to an event. You can save this class in a separated file and add multiple events to it as public static strings. Enums Action.TrainARActionChoices The type of interaction to check against. ActionFork.TrainARActionChoices The type of interaction to check against. ActionMulti.TrainARActionChoices The type of interaction to check against. ActionUI.TrainARUIActionChoices The type of UI questionnaire triggered and check against. ObjectHelper.TrainARHelperChoices The available helper utility to select on the \"TrainAR: Object Helper\" nodes menu."
  },
  "api/Visual_Scripting.Insights.html": {
    "href": "api/Visual_Scripting.Insights.html",
    "title": "Class Insights | TrainAR Documentation",
    "keywords": "Class Insights Implements the \"Insights\" functionality of the TrainAR Framework, therefore it triggers the expert input modality to show additional insights and tips and optionally plays audio clips. Inheritance Object Insights Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class Insights : Unit Properties | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. | Improve this Doc View Source InsightAudioClip The audioclip to be played with the expert insights. Declaration public ValueInput InsightAudioClip { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source InsightExpertImage The image/symbol to be displayed as the \"expert\" next to the text. Declaration public ValueInput InsightExpertImage { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source InsightText The instruction text that is displayed for the current step. Declaration public ValueInput InsightText { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source OutputFlow The Output port of the Unit that is tirggered after executing the units logic. Declaration public ControlOutput OutputFlow { get; } Property Value Type Description ControlOutput Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input, output and value ports. Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.Instructions.html": {
    "href": "api/Visual_Scripting.Instructions.html",
    "title": "Class Instructions | TrainAR Documentation",
    "keywords": "Class Instructions Implements the \"Instruction\" functionality of the TrainAR Framework, therefore it updates the isntrutions and progress percentage of the Top panel. Inheritance Object Instructions Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class Instructions : Unit Properties | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. | Improve this Doc View Source instructionText The instruction text that is displayed for the current step. Declaration public ValueInput instructionText { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source OutputFlow The Output port of the Unit that is tirggered after executing the units logic. Declaration public ControlOutput OutputFlow { get; } Property Value Type Description ControlOutput Set in node in the editor. | Improve this Doc View Source progressPercentage The percentage that is displayed for the current step. Declaration public ValueInput progressPercentage { get; } Property Value Type Description ValueInput Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input, output and value ports. Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.ObjectHelper.html": {
    "href": "api/Visual_Scripting.ObjectHelper.html",
    "title": "Class ObjectHelper | TrainAR Documentation",
    "keywords": "Class ObjectHelper The Object helper provides utility methods to toggle visibility, grabbability, interactability, and combinability of TrainAR objects, to destroy them, to get GameObject references to TrainAR object in the stateflow and many other utility functions. Inheritance Object ObjectHelper Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class ObjectHelper : Unit Fields | Improve this Doc View Source helperChoice Declaration public ObjectHelper.TrainARHelperChoices helperChoice Field Value Type Description ObjectHelper.TrainARHelperChoices Properties | Improve this Doc View Source CombinabilityToggle Toggle for the combinability that is displayed when this helper is selected. Declaration public ValueInput CombinabilityToggle { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source FusionOffsetPosition The positional offset of the fusion of the objects. Declaration public ValueInput FusionOffsetPosition { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source FusionOffsetRotation The rotational offset of the fusion of the objects. Declaration public ValueInput FusionOffsetRotation { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source GrabbabilityToggle Toggle for the grabbability that is displayed when this helper is selected. Declaration public ValueInput GrabbabilityToggle { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source InputFlow The Input port of the Unit that triggers the internal logic. Declaration public ControlInput InputFlow { get; } Property Value Type Description ControlInput Set in node in the editor. | Improve this Doc View Source InteractabilityToggle Toggle for the interactability that is displayed when this helper is selected. Declaration public ValueInput InteractabilityToggle { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source InteractableText The interactable text that is displayed on the interaction button. Declaration public ValueInput InteractableText { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source Lerpingdistance The lerping distance of the object to the smartphone. Declaration public ValueInput Lerpingdistance { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source ObjectMaterial Texture to replace. Declaration public ValueInput ObjectMaterial { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source ObjectMesh Mesh to replace. Declaration public ValueInput ObjectMesh { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source objectReference The reference to the GameObject in the scene. Declaration public ValueOutput objectReference { get; } Property Value Type Description ValueOutput Set in node in the editor. | Improve this Doc View Source ObjectTwo The second object to fuse together (with the original one). Declaration public ValueInput ObjectTwo { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source OutputFlow The Output port of the Unit that is tirggered after executing the units logic. Declaration public ControlOutput OutputFlow { get; } Property Value Type Description ControlOutput Set in node in the editor. | Improve this Doc View Source TrainARObjectName Name of the Object we want to get the reference for. Declaration public ValueInput TrainARObjectName { get; } Property Value Type Description ValueInput Set in node in the editor. | Improve this Doc View Source VisibilityToggle Toggle for the visibility that is displayed when this helper is selected. Declaration public ValueInput VisibilityToggle { get; } Property Value Type Description ValueInput Set in node in the editor. Methods | Improve this Doc View Source Definition() Defines the Nodes input, output and value ports Declaration protected override void Definition()"
  },
  "api/Visual_Scripting.ObjectHelper.TrainARHelperChoices.html": {
    "href": "api/Visual_Scripting.ObjectHelper.TrainARHelperChoices.html",
    "title": "Enum ObjectHelper.TrainARHelperChoices | TrainAR Documentation",
    "keywords": "Enum ObjectHelper.TrainARHelperChoices The available helper utility to select on the \"TrainAR: Object Helper\" nodes menu. Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public enum TrainARHelperChoices Fields Name Description ChangeInteractionText ChangeLerpingDistance DestroyObject FuseTwoObjects GetObjectReference ReplaceMeshAndTexture ReplaceTrainARObject ToggleCombinable ToggleGrabbable ToggleInteractable ToggleVisibility"
  },
  "api/Visual_Scripting.OnboardingSetup.html": {
    "href": "api/Visual_Scripting.OnboardingSetup.html",
    "title": "Class OnboardingSetup | TrainAR Documentation",
    "keywords": "Class OnboardingSetup Adds an EventHook for the onboarding setup that is used to trigger the start of the visual scripting stateflow after the onboarding was completed. Inheritance Object OnboardingSetup Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public class OnboardingSetup : EventUnit<bool> Properties | Improve this Doc View Source register Declaration protected override bool register { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source GetHook(GraphReference) Adding an EventHook with the name of the event to the list of visual scripting events. Declaration public override EventHook GetHook(GraphReference reference) Parameters Type Name Description GraphReference reference Returns Type Description EventHook The event for visual scripting."
  },
  "api/Visual_Scripting.VisualScriptingEventNames.html": {
    "href": "api/Visual_Scripting.VisualScriptingEventNames.html",
    "title": "Class VisualScriptingEventNames | TrainAR Documentation",
    "keywords": "Class VisualScriptingEventNames Registering a string name for your custom event to hook it to an event. You can save this class in a separated file and add multiple events to it as public static strings. Inheritance Object VisualScriptingEventNames Namespace : Visual_Scripting Assembly : Assembly-CSharp.dll Syntax public static class VisualScriptingEventNames Fields | Improve this Doc View Source OnboardingAndSetupCompleted Declaration public static string OnboardingAndSetupCompleted Field Value Type Description String"
  },
  "index.html": {
    "href": "index.html",
    "title": "TrainAR | TrainAR Documentation",
    "keywords": "TrainAR TrainAR is a holistic threefold combination of an interaction concept, didactic framework and authoring tool for Augmented Reality (AR) trainings on handheld Android and iOS devices ( Blattgerste et al. 2021 ). It is completely open source, free and offers non-programmers and programmers without AR-specific expertise aiding in the creation of interactive, engaging, procedural Augmented Reality trainings. This repository contains the technical components of the interaction concept and authoring tool of TrainAR in form of a custom Unity 2022.3 (LTS) Editor Extension. It can be used with the Unity Windows, macOS (Silicon), macOS (Intel), or Linux Editor and deploy to Android and iOS devices. The authoring tool already offers features like the onboarding animations, tracking solutions, assembly placements, evaluated interaction concepts, layered feedback modalities and training assessments of TrainAR out of the box. This allows authors of AR trainings to focus on the content of the training instead of technical challenges. Authors can simply import 3D models into the tool, convert them to TrainAR objects and reference them in a visual-scripting stateflow (that is inspired by work-process-analyses) to create a procedural flow of instructions, user actions and feedback. The idea behind TrainAR is simple: Realistic deployments of head-mounted AR devices still remain a challenge today because of high costs, missing relevant training, and novelty of interactions that require in-depth onboarding. In contrast, smartphone-based AR would be realistically scalable today, while still retaining many of the learning benefits. At least in theory. While possible, most mobile AR learning applications focus on visualisation instead of interactions today, severely limiting their application scope. In line with recent findings that, in terms of training outcome, tangible interactions are not significantly increasing retention or transfer of knowledge compared to purely virtual interaction approaches ( Knierim et al. 2020 ), the idea of TrainAR is a holistic and scalable solution for procedural task training using Augmented Reality on handheld AR devices. Hereby, the idea is not to replace practical trainings but use TrainAR scenarios for concept and procedure understanding in preparation for or retention training after the practical training sessions. In line with Gagne 1984 , it is envisioned as a novel type of multimedia source to train intellectual skills and cognitive strategies but does not train associated motor skills . TrainAR Training Scenarios Several TrainAR trainings were already developed by us, researchers from partner universities, and students using preliminary versions of the TrainAR authoring tool. They span across the contexts of medical education, nursing education, chemical engineering, science educational, manual assembly, and everyday work tasks. A list of publications for some of the trainings can be found below. Documentation & Getting Started If you want to try out already developed TrainAR trainings, here is a list of available Apps that utilize TrainAR: Training scenario \"Preparation of a tocolytic injection\" in the Heb@AR App [ Youtube , Android & iOS ] Training scenario \"Pelvis Termini\" in the Heb@AR App [ Youtube , Android & iOS ] If you want to get started with creating, deploying and playing with your own TrainAR training, check out our Getting Started Guide . You can either use the example scenario that ships with this repository, or create a very simple example scene from the guide in less than half an hour. Beyond the Getting Started Guide, a full documentation is available detailing the available visual scripting nodes , how to create TrainAR objects and how to use nodes to implement action flows . Additionally, a complete documentation of all API references is included. A key idea behind TrainAR is the retention of the full Unity capabilities while offering a higher-level abstraction for non-programmers to get started with AR authoring. Therefore, it can also be utilized without the visual scripting and without the TrainAR authoring overlay, using the standard Unity Editor Overlay and C# programming. This could for example be interesting, if you want to implement non-procedural educational games or you are only interested in the components of the interaction concept and not so much the authoring tool itself. For this, check out the Advanced Options documentation. Contributing to this Project TrainAR is envisioned as a participatory project, continously improving and expanding it's quality and scope. Feel free to contribute to its source code, documentation or conceptual/didactic ideas through Issues or Discussions . You are using TrainAR for an Augmented Reality training or learning game? Show us what you created! You are using TrainAR to explore Augmented Reality trainings in a new context as your scientific research? Feel free to add your publications to our list of publications below so others can use it as a reference. Publication List TrainAR Framework: Blattgerste, J.; Behrends, J.; Pfeiffer, T. (2023) TrainAR: An Open-Source Visual Scripting-Based Authoring Tool for Procedural Mobile Augmented Reality Trainings . Information, 14 (4), 219. Blattgerste, J., & Pfeiffer, T. (2022). TrainAR: Ein Augmented Reality Training Autorensystem . Wettbewerbsband AVRiL 2022. Blattgerste, J., Luksch, K., Lewa, C., & Pfeiffer, T. (2021). TrainAR: A Scalable Interaction Concept and Didactic Framework for Procedural Trainings Using Handheld Augmented Reality . Multimodal Technologies and Interaction, 5 (7), 30. TrainAR Trainings: Arztmann, M., Domínguez Alfaro, J. L., Hornstra, L., Jeuring, J., & Kester, L. (2023). In-game performance: The role of students' socio-economic status, self-efficacy and situational interest in an augmented reality game . British Journal of Educational Technology, 00, 1–15. Blattgerste, J., Franssen, J., Arztmann, M., Pfeiffer, T. (2022). Motivational benefits and usability of a handheld Augmented Reality game for anatomy learning . 2022 IEEE International Conference on Artificial Intelligence and Virtual Reality (AIVR). Arztmann, M., Domínguez Alfaro, J. L., Blattgerste, J., Jeuring, J., Van Puyvelde, P. (2022). Marie’s ChemLab: a Mobile Augmented Reality Game to Teach Basic Chemistry to Children . European Conference on Games Based Learning. Domínguez Alfaro, J. L., Gantois, S., Blattgerste, J., De Croon, R., Verbert, K., Pfeiffer, T., & Van Puyvelde, P. (2022). Mobile Augmented Reality Laboratory for Learning Acid–Base Titration . Journal of Chemical Education, 99(2), 531–537. Blattgerste, J., Vogel, K., Lewa, C., Willmeroth, T., Joswig, M., Schäfer, T., ... & Pfeiffer, T. (2022). The Heb@ AR App–Five Augmented Reality Trainings for Self-Directed Learning in Academic Midwifery Education . DELFI 2022 – Die 20. Fachtagung Bildungstechnologien der Gesellschaft für Informatik eV. Blattgerste, J., Luksch, K., Lewa, C., Kunzendorf, M., Bauer, N. H., Bernloehr, A., ... & Pfeiffer, T. (2020). Project Heb@AR: Exploring handheld Augmented Reality training to supplement academic midwifery education . DELFI 2020 – Die 18. Fachtagung Bildungstechnologien der Gesellschaft für Informatik eV. Funding The research resulting in the open source TrainAR project was partially supported by the grant 16DHB3021, project \"HebAR - AR-Based-Training-Technology\", by the German Ministry for Education and Research (BMBF) [ 1 ] and partially by the Mixed Reality Lab at University of Applied Sciences Emden/Leer. TrainAR is the abstraction and generalization of interaction concepts, feedback mechanisms, and didactic ideas developed during Project Heb@AR [ 1 , 2 ]. Here, procedural Augmented Reality emergency trainings were explored in the academic midwifery education context. During the development it became clear that those concepts could also be generalized towards other training contexts and thus we share TrainAR here. Acknowledgement TrainAR is freely accessible for commercial and non-commercial use under the MIT license and does not require acknowledgement in your TrainAR training or App itself. If you use TrainAR in the scientific context though, please acknowledge it by citing our publications on the interaction concept, didactic considerations and the authoring tool itself: @article{Blattgerste2023TrainAR, AUTHOR = {Blattgerste, Jonas and Behrends, Jan and Pfeiffer, Thies}, TITLE = {TrainAR: An Open-Source Visual Scripting-Based Authoring Tool for Procedural Mobile Augmented Reality Trainings}, JOURNAL = {Information}, VOLUME = {14}, YEAR = {2023}, NUMBER = {4}, ARTICLE-NUMBER = {219}, URL = {https://www.mdpi.com/2078-2489/14/4/219}, ISSN = {2078-2489}, DOI = {10.3390/info14040219} }"
  },
  "manual/ActionNodes.html": {
    "href": "manual/ActionNodes.html",
    "title": "Action Nodes | TrainAR Documentation",
    "keywords": "Action Nodes TrainAR: Action nodes define, which are the correct actions to take for the user in the AR-Training. There are action nodes that require an input in the AR-Context, so interactions with or combination of TrainAR Objects, but there are also action nodes which require input of the user on the user interface (UI Action Nodes), which are documented separately in the UI Action Node documentation. AR interactions with Action Nodes Interacting with TrainAR Objects in the AR context is possible in two ways: interacting and combining . The node can be set to the type of interaction via the \"Action\" drop down menu. This node is set to Interaction. If the stateflow reaches this point, the node waits for an action by the user. If the user triggers an interact with the TrainAR Object specified in Correct object , the stateflow continues according to the Correct -Output of the node. Consequently, if any other action is taken by the user, the stateflow continues according to the Incorrect -Output of the node. For Combinations the node works similarly, though two objects have to be specfied: the grabbed objects, so the one the user is currently holding, and the object the grabbed object is supposed to be combined with. Custom Action With the Action Node set to Custom Action it is also possible to control the stateflow with your own custom actions/triggers as described in the Advanced Options . In that case, you need to request a state change to the StatemachineConnector with a parameter. This parameter is checked against the parameter defined in the node and then determined as either Correct or Incorrect - the stateflow then resumes accordingly. In this example the correct parameter is defined as \"correctParameter\". The following example describes how to request a state change to the StatemachineConnector through C# scripting: parameterToCheck = \"correctParameter\"; StatemachineConnector.Instance.RequestStateChange(new StateInformation(parameter: parameterToCheck)); parameterToCheck = \"wrongParameter\"; StatemachineConnector.Instance.RequestStateChange(new StateInformation(parameter: parameterToCheck)); In the first call to the StatemachineConnector the stateflow continues according to the Correct -output of the node, since parameterToCheck is set to the the correct parameter. The second call to the StatemachineConnector results in triggering the Incorrect -output of the node, since this is not the parameter specified in the node. TrainAR: Action (Fork) Sometimes you may run into situations where the training procedure you're creating has multiple correct actions at one point. Maybe those actions might even result in a different stateflow after this point. e.g. because there is multiple orders for sub-sequences of the procedure. TrainAR: Action (Fork) let you specify multiple correct actions and the stateflow these actions are supposed to result in. The number specified in the Action count field defines the number of TrainAR Objects with whom an action is considered correct. Consequently, if the number is changed, the node adjusts itself, so the specified number of Correct objects and their stateflows can be defined. This of course also works analogous with Combinations . TrainAR Action (Multi) In other cases when creating your training you might run into situations, where multiple actions have to happen, but it doesn't necessarily have to be in in a strict order (e.g. combining multiple TrainAR Objects like vegetables with a soup bowl). These cases can be modeled with the TrainAR: Action (Multi) node. The All correct stateflow is triggered once, when all of the defined actions have been performed. If any other actions is registered, the incorrect stateflow is triggered repeatedly on each incorrect action."
  },
  "manual/FeedbackNode.html": {
    "href": "manual/FeedbackNode.html",
    "title": "Feedback Node | TrainAR Documentation",
    "keywords": "Feedback Node The Feedback Node triggers an UI-Overlay, which covers the whole smartphone screen and displays feedback to the user. Therefore it's recommended use is for espeacially important textual feedback, where a simple red blinking outline would not be sufficient. In the node, a header text and the feedback text have to be specified. From the didactic perspective, this is intended to be used to provide feedback to the user of the training: Telling the user what he did wrong or what he could do to continue. For more detail, read our publication on the TrainAR interaction concept and didactic framework: \"TrainAR: A Scalable Interaction Concept and Didactic Framework for Procedural Trainings Using Handheld Augmented Reality\" TrainAR Node Result"
  },
  "manual/GettingStarted.html": {
    "href": "manual/GettingStarted.html",
    "title": "Getting Started Guide | TrainAR Documentation",
    "keywords": "Getting Started Guide The Getting Started Guide is meant to provide a \"quickstart\" for your development of TrainAR trainings and guides you through the process of creating a very simple TrainAR training from scratch. This Getting Started Guide presumes that you already completed the Installation & Setup of Unity and TrainAR. There is a training assembly included in the TrainAR repository that can be deployed directly for testing. You can also try to deploy and test this example first and play around with it as we will delete this shortly: For this, directly skip to \" Deploy your training to your phone \". Delete the example TrainAR training If you started the TrainAR Unity project with Unity Version 2022.3 (LTS) through the Unity HUB (as described in Installation & Setup ) and opened the TrainAR Authoring Tool through the top-panel menu item called \"TrainAR\" -> \"Open TrainAR Authoring Tool\". You should now see the TrainAR Authoring Tool roughly like this: As you can see, there already is a TrainAR training. But we want to develop a TrainAR training from scratch and therefore have to delete the example training. For this we have to delete all TrainAR Objects and the TrainAR stateflow. To accomplish this, we can click somewhere into the Scene (blue) press CTRL + A and then Delete / DEL ( Backspace on macOS) to delete all TrainAR Objects. Afterwards, click somewhere into the Scripting Graph (red) and then again press CTRL + A to select the complete stateflow in the TrainAR statemachine. Deselect the very first node (\"TrainAR: Onboarding completed and training assembly placed\"), as we need this for each training. Then press Delete / DEL ( Backspace on macOS). This deletes the complete TrainAR Stateflow. and the TrainAR Authoring Tool should look roughly like this: In the scene window you should now still see the reference setup of the current Workspace (a room of black tiles, a table and a female character) but no TrainAR Objects in the Hierarchy or Scene and only the very first, green \"TrainAR: Onboarding completed and training assembly placed\" node. The reference setup should give you an idea of the size of objects in regards to the real world when viewed in the authoring tool and is not deployed with the TrainAR training. Create TrainAR Objects On the left in the Hierarchy tab is a (currently empty) list of the objects in the scene. On the Bottom Left, in the Project Tab open the Prefabs folder. There is a Prefab named Spoon_Prefab . Click on this Prefab and drag-and-drop it into the Hierarchy Tab. The spoon should appear on the table. To interact with this object, you'll have to convert it to a TrainAR Object. To achieve this select the object either in the hierarchy or directly in the scene tab. Press the button with the label Convert to TrainAR Object that now appears on the bottom left of the scene tab. A preview window showing the chosen object should appear. This window gives you more specific options before you start the conversion process. For now, just ignore those and click on Convert to TrainAR Object \". You can move the newly created TrainAR object around, rotate it or change its size. To do this, you can switch between different tools in the Tools Bar in the Scene View. For now make sure the Move tool is selected and move the object in a fitting position on the reference-table. Now add Coffee_Tin_Prefab from the Prefabs folder, unpack it and convert it to an TrainARObject, then position it. Your setup should now look kind of like this: Good! You converted and placed some TrainAR Objects onto the Training Assembly. You could already deploy this training to a device and see your objects in AR but they would not elicit any behaviour or feedback based on the users actions. For this we have to connect the TrainAR Objects in our TrainAR Stateflow. Create a TrainAR Stateflow In the Bottom of the Unity window you should see the window with the Script Graph Tab. Here you can create the flow of your training by creating nodes and connecting them. There already is one node in the Script Graph with the description TrainAR: Onboarding completed and training assembly placed . This is the entry point of your training flow and makes sure that when you training starts, TrainAR already handled onboarding and the training assembly was placed into a valid position by the user. Right click into the Script Graph Window and select TrainAR from the Node Menu. From there, select TrainAR: Action . The TrainAR Action node should appear in the Stateflow. There are two types of action you can define: Interaction and Combination. For now leave the chosen action to Interaction. In the TrainAR: Action node under the Correct Action textfield type in Spoon . Now connect the two nodes by clicking on the output of the TrainAR: Onboarding completed and training assembly placed node and connecting the line with the input of the TrainAR: Action node. You have now defined that, at this point in the stateflow (the very start), the correct next step is to trigger an Interaction on the TrainAR Object Spoon . Right click again in the Script Graph window to open the node menu and select the TrainAR: Feedback node in the TrainAR nodes folder. This node opens an error overlay. Type a fitting error messages in the textfield and connect the Incorrect output of the TrainAR: Action node with the Input of the TrainAR: Feedback node. You have now defined what happens if an incorrect action is taken at this point in the stateflow. Now define what should happens if the correct action is taken. Create another TrainAR: Feedback node and type in feedback for the correct action taken and connect it to the correct output of the TrainAR: Action node. Note: This is for demonstration purposes only, Feedback nodes should normally be used for errors and not positive feedback as described in the didactic considerations of our research paper: TrainAR: A Scalable Interaction Concept and Didactic Framework for Procedural Trainings Using Handheld Augmented Reality . Now create another TrainAR: Action node and connect it to the TrainAR Feedback for the correct feedback. Select Combination as an Action in the node. Under Correct Grabbed Object type in Spoon and under Correct stationary Object type in Coffee_Tin . Connect the nodes. You have now defined, that at this point in the stateflow, the correct step is to combine the spoon with the coffee tin. Next you'll have to define what happens as a result. Let's make the combine fill up the spoon. To do this add a TrainAR: Object Helper node to the stateflow. In the node, set the dropdown menu to Replace Mesh and type in the Object Name field Spoon . In the Project Tab navigate to the Meshes folder and drag-and-drop the SpoonFilled mesh into the mesh field of the node. Then, drag-and-drop the SpoonFilled material from the Materials folder into the material field. Finally, connect the stateflow. This basically tells TrainAR, that we want to replace this objects shape and texture as a result of this action (because now there is coffee in it). Afterwards, add a TrainAR: Action (UI) node. A node that can trigger UI Custom Actions. Set the dropdown menu in the node you just created to Questionnaire . A UI action node waits for user input on the UI before it continues in a stateflow. In this example, we'll simply ask the user whether or not he want's to finish the training. Therefore write a fitting Questiontext in the Question field of the node and add some chooseable answers. Don't forget to connect the stateflow of the previous node. Finally, create a TrainAR: Training Conclusion node and connect the node from the previous step with it. This tells TrainAR to show the TrainAR Training Assessment and that we are done with the training. Done! The full process from start to finish Here is the full process of creating this simple training from scratch in one go: Deploy your training to your phone Connect your (Android) phone to your Computer. Make sure you have USB Debugging activated on your phone. Press the play button in the Unity Editor to deploy your training to your device. Wait for the process to finish. Afterwards, unlock your phone. Your Training should now be deployed to your phone and automatically start. It should also appear as a \"TrainAR\" App, installed on your device in the menu. Test your training If it did not open automatically, open the now deployed application on your phone through the menu. Your phone might ask you if the TrainAR app should be allowed to use your phones camera. Confirm this, as we need the camera to use Augmented Reality. A short tutorial that describes the interaction concept of TrainAR should appear. Navigate through the tutorial/onboarding to start your training. The camera feed of your device should start and you're asked to find a flat surface to scan. Follow these instructions. This should result in the setup you just created being placed onto a table surface. Now you can go through the chain of actions you just defined into the TrainAR Stateflow, which should look roughly like this:"
  },
  "manual/InsightNode.html": {
    "href": "manual/InsightNode.html",
    "title": "Insight Node | TrainAR Documentation",
    "keywords": "Insight Node The TrainAR Insight nodes may be used to show additional insights, hints or tips to the user. Textual insights can also be given in combination with a soundfile (e.g. for voice recordings) and an image may be specified in this node. This could for example be the \"expert\" providing the insights. From the didactic perspective, this is intended to be used to provide additional insights or tips from experience/practise to the user: Telling the user how this would look in practice, telling the user what he should be careful about when training this procedure in real life. It is not intended to provide direct feedback or new instructions to the user. For more detail, read our publication on the TrainAR interaction concept and didactic framework: \"TrainAR: A Scalable Interaction Concept and Didactic Framework for Procedural Trainings Using Handheld Augmented Reality\" TrainAR Node Result"
  },
  "manual/InstructionNode.html": {
    "href": "manual/InstructionNode.html",
    "title": "Instruction Node | TrainAR Documentation",
    "keywords": "Instruction Node With the Instruction node, authors can update the text and the progress percentage on the top panel shown at the top of the smartphone screen. Consequently, authors can specify the instruction text and the progress percentage in the node. From the didactic perspective, this is intended to be used to provide instructions to the user of the training: Telling the user what to do next. For more detail, read our publication on the TrainAR interaction concept and didactic framework: \"TrainAR: A Scalable Interaction Concept and Didactic Framework for Procedural Trainings Using Handheld Augmented Reality\" TrainAR Node Result"
  },
  "manual/NoVisualScripting.html": {
    "href": "manual/NoVisualScripting.html",
    "title": "Advanced Options - AR Beyond the Train__ | TrainAR Documentation",
    "keywords": "Advanced Options - AR Beyond the Train__ TrainAR is mainly aimed towards non-programmers, designer and domain-experts that do have significant media competency but not necessarily programming expertise. Nontheless, TrainAR can also aid the AR development of people with programming skills and Unity expertise. As a central concept, TrainAR is integrated into the Unity Editor as a host software for the simple reason, that this allows people to expand the framework at will to realize trainings outside of the original scope of TrainAR. Several deliberate design decisions were made to keep this possibility and there are multiple options to break out of the TrainAR scope as explained below. Generally, not meant to be a technical documentation but rather an abstract visualization for explanatory purposes of the following documentation: A TrainAR training technically starts with the Prefab Spawning Controller that allows the user to place the training assembly in the environment and signals the Onboarding Controller when and where sufficiently large surfaces were detected. After the assembly is placed, the Interaction Controller is triggered and starts to listen to the Interaction Button Controller . When a Button (e.g. interaction or combination) is pressed, while a TrainAR Object is selected, the TrainAR Object sends a request to change its state in form of a State Information struct to the Statemachine Connector . The Statemachine Connector then hands this State Information to the Visual Statemachine which then checks it against its internal state set by the author of the training and answers to the Statemachine Connector if this request was a valid or invalid request. On the one hand, the Statemachine Connector then hands this information back to the TrainAR Object, which can then trigger object-level behaviours based on this decision (e.g. shading, audio playbacks, outling, animations, Custom events or physics). On the other hand the Statemachine Connector also triggers flow-level Actions for the Questionnaire Controller , Top Panel Controller , Error Overlay Controller , and Direct Info Controller when requested by the Visual Statemachine as a consequence of this action. Unity Visual Scripting Nodes The first and easist possibility is to utilize non-TrainAR Unity Visual Scripting nodes inside of a TrainAR Stateflow. E.g. to delay feedback by using the cooldown node before executing the next TrainAR node as shown in the figure below. This effectively provides the possibility of expanding the flow-level behaviour possibilities of TrainAR to match the Unity Visual Scripting abstraction layer on demand. Switching to the default Unity Editor Secondly, authors can switch to the regular Unity Editor layout by navigating to the TrainAR Tab at the top of the screen and clicking on Open Unity Editor . This can be used to access and customize object-level behaviours like collision, physics, outlining, materials, shaders, transform components, or use the object-level behaviour events that are exposed on the \"TrainAR Object\" and trigger Unity components or custom C# behaviours based on them. This transition is hereby seemless and authors can create a basic flow using the Authoring Tool and then customize more indepth object-level behaviours in the Unity Editor layout if necessary. Using Custom Actions for Advanced Behaviours One way to expand the flow-level behaviours outside of the provided functionality of the TrainAR Framework, while still using the visual scripting component for the Statemachine, is to use Custom Actions. Here, authors can either attach the CustomAction component to a GameObject (not necessarily a TrainAR Object) and call the DynamicTrigger() function or call the CustomAction.StaticTrigger() in the static context from anywhere in the solution. public class CustomAction : MonoBehaviour { public void DynamicTrigger(string parameter) { StaticTrigger(parameter); } public static bool StaticTrigger(string parameter) { return StatemachineConnector.Instance.RequestStateChange(new StateInformation(interactionType:InteractionType.Custom, parameter:parameter)); } } Using TrainAR without the Visual Statemachine Finally, while the visual scripting is an integral part of TrainAR, it is possible to use TrainAR without the visual scripting and the TrainAR visual statemachine component. This can for example be useful to implement non-procedural or rule-based training stateflows or to develop AR learning games based on the framework that only utilize interaction and feedback modalities without the didactic ideas behind TrainAR. As visualized in the technical flow figure, the Visual Statemachine is only communicating with the Statemachine Connector through State Information structs. To disable visual scripting, authors simply need to comment a specific piece of code in the StatemachineConnector in the function RequestStateChange() . Look for this part: acceptedStateChange = stateInformation.interactionType switch { InteractionType.Grab => true, //For grabbing this is always true, selection, deselection and release are not calling this InteractionType.Combine => stateChangeTrigger.Invoke(stateInformation), InteractionType.Interact => stateChangeTrigger.Invoke(stateInformation), InteractionType.Custom => stateChangeTrigger.Invoke(stateInformation), _ => acceptedStateChange }; And and comment it out like this: /* acceptedStateChange = stateInformation.interactionType switch { InteractionType.Grab => true, //For grabbing this is always true, selection, deselection and release are not calling this InteractionType.Combine => stateChangeTrigger.Invoke(stateInformation), InteractionType.Interact => stateChangeTrigger.Invoke(stateInformation), InteractionType.Custom => stateChangeTrigger.Invoke(stateInformation), _ => acceptedStateChange }; */ If authors choose to do this, they have to handle the requested statechange themselves by analyzing the provided State Information struct and returning true or false within the function to communicate the acceptance or denial of the request. The processing of this information is then still handled by the TrainAR framework. They furthermore have to handle the feedback modalities like instructions, feedback UI, questionnaires or expert insights manually. This is possible by just manually calling the methods UpdateTopPanel() , ShowErrorOverlay() , StartQuestionUI() , ShowExpertInsights() , and ShowCompletionOverlay() in the Statemachine Connector to trigger corresponding Actions that are then also automatically executed by the TrainAR framework."
  },
  "manual/ObjectHelperNode.html": {
    "href": "manual/ObjectHelperNode.html",
    "title": "Object Helper Node | TrainAR Documentation",
    "keywords": "Object Helper Node As specified in the TrainAR Objects documentation, TrainAR Objects have states and behaviours. The Object Helper nodeprovides various options to access and modify these from within the TrainAR Stateflow at runtime of the TrainAR training. In the Helper dropwodn menu you can select from the different options. To specifiy which TrainAR Object in the scene you want to modify, specify the exact Object name in the node. TrainAR Node Result Toggle Visibility Check or uncheck the Visible field to make the specified TrainAR Object visible or invisible. Toggle Grabbable Check or uncheck the Grabbable field to make the specified TrainAR Object grabbable or not grabbable. Toggle Interactable Check or uncheck the Interactable field to make the specified TrainAR Object interactable or not interactable. Toggle Combinable Check or uncheck the Combinable field to make the specified TrainAR Object combinable or not combinable. Change Interaction text Changes the labeling of the interaction button when selecting an TrainAR Object. A TrainAR Object is selected when you aim at a TrainAR Object and move close to it. By default the labeling is simply Interact for every TrainAR Object. Change Lerping distance This changes the distance with which a grabbed TrainAR Object floats away from the screen. Generally, you probably want to have bigger TrainAR Objects float at a larger distance than smaller ones. That way, they don't cover the whole screen while grabbing them. Change Mesh and Texture With this option, you can change what a TrainAR Object looks like by changing it's mesh and/or material. This is for example useful if as a result of a combination or interaction an object is supposed to be altered. Get Object Reference This node returns the Unity GameObject Reference of the specified TrainAR Object . For more information about Unity GameObjects, refer to the Unity Documentation . This is mainly useful if you want to utilize Unitys Visual Scripting nodes in the Stateflow as specified in the Advanced Options . Fuse Two Objects The Fuse-Object setting attaches one TrainAR Object to another, making them one. The Object name field specifies the object that is fused onto the other object. The other object is specified in the Fuse to Object field. In the Offset Position and Rotation field the position and rotation relative to the fused with TrainAR Object is specified. To determine the offset position and rotation, place the two objects in the desired position and rotation in the scene view. Then select both of these objects (shift-click on each of them). A toolbar should appear on the bottom left of the scene view, which displays the offset position and rotation of the selected objects. These are the offset values you need to enter in the Object Helper Node . When you're done entering the values, don't forget to reset the objects to their default position and rotation in the scene view. Note: You may need to flip the signing of the values when entering them in the Object Helper node (i.e.: -1.5 becomes 1.5 and vice versa). Destroy Object Destroys and removes the specified TrainAR Object from the scene. Replace TrainAR Object Replaces a to be replaced TrainAR Object with another replacing TrainAR Object . The replaced TrainAR Object is set to invisible. The replacing TrainAR Object is also placed at the same position as the replaced TrainAR Object . In case the replaced TrainAR Object is grabbed during replacement, the replacing TrainAR Object is also grabbed . For further instructions on how to use this setting, see here"
  },
  "manual/Setup.html": {
    "href": "manual/Setup.html",
    "title": "Installation & Setup | TrainAR Documentation",
    "keywords": "Installation & Setup Download & Install Unity First, download and install the Unity Hub . The Unity Hub allows you to easily install the correct Unity Editor version and corresponding packages that are needed for platform specific deployments. After installing Unity HUB, install Unity Version 2022.3 (LTS) as described in the Unity Hub Documentation . When installing Unity, make sure to also indlude the correct modules, depending on which kind of device you want to deploy the TrainAR trainings to: For Android choose Android Build Support. Make sure to have also Android SDK & NDK Tools and OpenJDK checked: For iOS, choose iOS Build Support: You can also install both at the same time to deploy to both devices. This works on every operating system (Linux, Windows and macOS), though for iOS, XCode on macOS is necessary to deploy to iOS devices after building the App. Futhremore, if you do not already have an IDE (Integrated Development Environment) installed and you plan to potentially use C# programming to expand TrainAR, we recommend also installing Microsoft Visual Studio with Unity. Get the TrainAR Authoring Tool After installing Unity we have to setup the TrainAR Authoring tool. There are two ways to accomplish this. Creating a Fork of the TrainAR Repository Manually downloading TrainAR We strongly recommend using the first approach. 1. Creating & Cloning a TrainAR Repository Fork Create a GitHub account. Fork the TrainAR repository into your account Download the GitHub Desktop client Clone the forked repository in the GitHub client Open the Unity HUB Add the now cloned repository through clicking \"Open\" and then selecting the folder that was downloaded in the GitHub client TrainAR should now appear in the list of projects and \"2022.3 (LTS)\" (or any 2022.3.XXXf subversion) should be selected as the Editor version. 2. Manually downloading TrainAR Alternatively, you can manually download TrainAR from the GitHub repository as a .zip file, unpack it and then open it in the Unity Hub by clicking \"Open\" and then selecting the folder that was downloaded in the GitHub client. While faster, we dont recommend this approach, as version control is a very helpful tool to prevent losing progress, e.g. because of errors or problems in the TrainAR framework. Opening the TrainAR Authoring Tool To now open the TrainAR Authoring Tool, select the \"TrainAR\" project in the Unity HUB to open it. After Unity is fully loaded, the top-panel menu should show \"TrainAR\" as an option, click this and then \"Open TrainAR Authoring Tool\". You should now see the TrainAR Authoring Tool like this:"
  },
  "manual/StartTrainingNode.html": {
    "href": "manual/StartTrainingNode.html",
    "title": "Start Training Node | TrainAR Documentation",
    "keywords": "Start Training Node The (green) Visual Scripting node called \"TrainAR: Onboarding completed and training assembly placed\" is an event node that is automically executed when the TrainAR framework recognizes that the user of the training finished watching the onboarding, a surface was found and the training assembly was placed by the user. It acts as a starting point for a TrainAR training created by the author. There should be only one \"TrainAR: Onboarding completed and training assembly placed\" node present in a TrainAR Stateflow. Note: While all other TrainAR nodes can be found under Right Click -> \"TrainAR\", the starting node is located under Right Click -> \"Events\". TrainAR Node Result"
  },
  "manual/TrainARBasics.html": {
    "href": "manual/TrainARBasics.html",
    "title": "TrainAR - The Basic Concepts | TrainAR Documentation",
    "keywords": "TrainAR - The Basic Concepts The TrainAR Authoring Tool can be utilized by understanding two basic concepts: The TrainAR Object and the TrainAR Stateflow . If you want to create a TrainAR scenario/training, you have to import 3D models (e.g. from the Assetstore, external websites or from a 3D scanner) and then convert them into TrainAR Objects. Once converted, they automatically inherit TrainAR-specific functionality/behaviours and states (position, rotation, scale, visibility, grabbability, interactability, combinability). TrainAR objects can then be referenced in the TrainAR Stateflow, which determines what action has to be taken next by the user of the TrainAR training and which kind of instruction, insight or feedback should be provided to the user. It additionally can manipulate states of TrainAR Objects during the training. As visualized in this figure, the TrainAR Authoring Tool provides an abstraction layer to easily access both. In blue is the Scene showing all TrainAR Objects currently in the training assembly. Here, their initial state can be manipulated (e.g. they can be positioned, rotated, they can prohibit being grabbed and be invisible at the start of the training). In Red is the TrainAR stateflow, where the flow of the training can be created and altered. The TrainAR Objects and TrainAR Stateflow can be connected by referencing TrainAR Objects in the TrainAR Stateflow by name. The rest is handled by the framework. Features like the onboarding animations, tracking solutions, assembly placement, interaction concepts, layered feedback modalities, expert insights, state management and training assessments are taken care of automatically. Notably, they can also be altered and expanded upon as described in the Advanced Options , if necessary. To provide a reference on what is possible with TrainAR, the following showreel shows 5 exemplary TrainAR trainings and games that were developed with TrainAR and evaluated by researchers at University of Applied Sciences Emden/Leer, KU Leuven, and Utrecht University: The following reference video shows the example TrainAR training shipped with the repository. On the left, the deployed TrainAR training is shown from the perspective of the user that is using the training and trying to interact with TrainAR Objects. On the right, the TrainAR Stateflow from the perspective of the author is visualized that determines the training procedure: TrainAR Documentation The TrainAR framework ships with this example training of \"preparing a coffee by using a coffee machine\" to provide a basic point of reference and startingpoint to authors. Beyond that, the documentation provides an Installation & Setup Guide and a Getting Started Guide that explains how to create a very basic, first training scenario in less than half an hour from scratch. Furthermore, a full documentation on TrainAR Objects and the TrainAR Stateflow with all its TrainAR Visual Scripting Nodes is provided. Finally, if experienced authors want to utilize TrainAR beyond the envisioned scope, there is multiple levels of advanced options that provide more powerful customization options to authors as described in the Advanced Options ."
  },
  "manual/TrainARNodes.html": {
    "href": "manual/TrainARNodes.html",
    "title": "TrainAR Nodes | TrainAR Documentation",
    "keywords": "TrainAR Nodes TrainAR Nodes are used in the TrainAR Stateflow to model the behaviour and procedural flow of the AR trainings created with TrainAR. TrainAR Nodes define what the next correct step in your training is but also how your training responds to correct or incorrect actions taken by the user. Consequently, there are TrainAR Nodes which wait for an Action to be taken by the user, these are called TrainAR Actions . TrainAR Actions consist of actions taken in the AR-context (so, grabbing, interacting or combining) or UI-actions (i.e a UI element which pops up and asks the user a question). How your training reacts to correct or incorrect steps taken by the user are defined by TrainAR Insight-, Instruction-, Feedback- and Object Helper Nodes . They are triggered instantly and continue the stateflow automatically after they performed their task. With these, you can instruct the user of the training, define the consequences of the users actions in the AR-context and give feedback or expert insights for these actions in the form of textual information displayed on the UI. Overview TrainAR Node Result Description Starts the TrainAR Stateflow Read more Waits for a Action (Interact, Combine or Custom) Read more Waits for an Action, Forks the Stateflow based on which Action was performed Read more Waits for n Actions to be performed (in any order) Read more Triggers and waits for a UI quiz to be answered Read more Shows new instructions to the user Read more Shows a feedback overlay to the user Read more Shows Insights (e.g. additional tips and tricks) to the user Read more Performs object-level behaviour/state changes Read more Concludes the training and TrainAR Stateflow Read more"
  },
  "manual/TrainArObjects.html": {
    "href": "manual/TrainArObjects.html",
    "title": "Creating and Converting TrainAR Objects | TrainAR Documentation",
    "keywords": "Creating and Converting TrainAR Objects To be able to use 3D assets/models for interactions in TrainAR trainings, you need to convert them to TrainAR Objects first. This gives them default TrainAR functionality/behaviours and makes them usable in the TrainAR Stateflow. To convert a 3D model into a TrainAR Object , simply drag-and-drop it from the project tab into the hierarchy tab. To start the conversion either right click on it in the hierarchy tab and select \"Convert to TrainAR Object\". Alternatively, while the object is selected, press the appearing button on the bottom left of the scene tab with the label Convert to TrainAR Object . Either way, a preview window displaying the selected object will appear. This window contains various settings for the conversion process: The optional Preview Mode , which lets you choose if you want to see the current object as a mesh, with its texture, or shaded (this is not applied to the converted object). The TrainAR Object Name , which is used to reference this specific object in the TrainAR Stateflow . The optional Move Pivot Point to Center setting, which automatically moves the point at which TrainAR Objects are grabbed to the objects center. The Object Simplification settings, which allows to simplify the object by either specifying a target polygon count (Vcglib Tridecimator algorithm, recommended ) or specify a quality reduction level (Quadric Error Metrics). To finalize the conversion simply press the Convert to TrainAR Object -button on the bottom of the preview window. Depending on how complex the object is, this may take a few seconds or even minutes. Note: An object may only be converted to a TrainAR Object, if it was not already converted and it has a Transform, MeshFilter and a MeshRenderer applied to it. SkinnedMeshRenderers are currently not supported. Object States A TrainAR Object has certain state attributes with which you can control in which kinds of ways the object can be interacted with. These states are: Visible: Whether or not this TrainAR Object is visible or invisible. Grabbable: If this is enabled, objects may be grabbed and moved around by the user. Therefore this should be disabled, in case of stationary objects. Interactable: Whether or not it is possible to trigger interactions on this object. Combineable: Whether or not it is possible to combine other TrainAR objects with it. If you have selected a TrainAR Object in the Authoring Tool, you can alter the state TrainAR objects start the training with by clicking on them in the Object State Toolbar . Note: You can also change TrainAR object states during the training through the Object Helper Node in the TrainAR Stateflow. Transform Tools With the Transform Tools you can configure your TrainAR Objects further. For example, you can move, rotate, or scale objects and alter their Bounding Box. The Transform tool is a convenient combination of the previous tools. With the Bounding Box Tool you can configure the bounding box of the object, which among other things, defines at what point TrainAR Objects are overlapping, so they can be combined with each other. Tip: Holding alt and clicking pins the center in place and clicking shift makes it possible to scale the bounding box uniformly. Swapping or modifying TrainAR Objects during a training One of the problems you'll run in quite frequently when creating trainings with TrainAR is that you want to modify TrainAR Objects or swap them out TrainAR Objects all together, for example as a result of an Interact or Combine . This can be achieved in various ways, some of which are explained in the following examples. Replacing the whole TrainAR Object You'll need to have prepared two 3D models as TrainAR Objects. One replacing object and one to be replaced object . Both need to be added to the training setup from the beginning, the replacing object can be set to invisible if it's not supposed to be in the training at training startup, from a user perspective. To replace one object with another use the TrainAR Node: Object Helper with the option Replace TrainAR Object . In the Object name textfield of the node put in the name of the replaced object and in the Replace with text field the name of the replacing object . The following two examples demonstrate this process. Example 1: Simple replacement In this example consisting of a packaged syringe that is supposed to be \"unpacked\" by replacing the packaged model with the unpackaged syringe. The user can do this by triggering an Interact on the packaged syringe. As a result, the packaged syringe model is then replaced by the unpackaged syringe. Add both TrainAR Objects in the training setup. Set the replacing object , in this case the syringe, to invisible. To open the package, the user is supposed to interact with the packaged syringe. Consequently, add a TrainAR Action node to the script graph, which references the packaged syringe TrainAR Object . As a result the packaged syringe is replaced with the syringe itself. Therefore add a TrainAR Object Helper node and choose the option Replace TrainAR Object . Then, enter the object names of the packaged syringe and the syringe in the respective fields in the node. Example 2: Combining two objects to one Sometimes you may want to model the attachment of one model to another. This can also be realized with the TrainAR Object Helper node, but with an additional step. In this example we want to connect a needle to the syringe. For this, three TrainAR Objects are needed: the syringe without needle, the syringe with needle and the needle. The syringe with needle needs to be set to invisible at the start of the training. At first, we again add a TrainAR Action node as a trigger for the replacement process, this time set to combine . The grabbed object in this case is the syringe and the stationary object is the needle. Next, the syringe is replaced via a TrainAR Object Helper node. Since the needle is now attached to the syringe, the needle model can be set to invisible. This is done as well with a TrainAR Object Helper node, but with the option Toggle Invisible . Fusing two Objects Another option is to directly attach one TrainAR Object to another TrainAR Object. This is possible when using TrainAR Object Helper with the option set to Fuse Two Objects . The Object name field specifies the object that is fused onto the object, which is specified in the Fuse to Object field. In the Offset Position and Rotation field the position and rotation relative to the fused with TrainAR Object is specified. To determine the offset position and rotation place the in the desired position and rotation in the scene view. Then select both of these objects (shift-click on each of them). A toolbar should appear on the bottom left of the scene view, which displays the offset position and rotation of the selected objects. These are the offset values you need to enter in the Object Helper Node to fuse them in the specified position and rotation. After you're done entering the values, don't forget to reset the objects to their default position and rotation in the scene view. Note: You may need to flip the signing of the values when entering them in the Object Helper node (i.e. -1.5 becomes 1.5 and vice versa). Object-level Behaviours Nothing to do here for now. TrainAR Objects automatically inherit all necessary behaviours like physics, collisions, outlining, sounds, shadows, interactions and many more for TrainAR to work consistently. There might be cases where you want more than what is provided. E.g. playing a specific sound on a specific combination of two objects, outlining this specific object on selection in pink (for some reason) or showing a cat GIF when this object is interacted with. How to accomplish these object-level behaviours by listening to TrainAR Object interaction events is described in the Advanced Options ."
  },
  "manual/TrainingConclusionNode.html": {
    "href": "manual/TrainingConclusionNode.html",
    "title": "Training Conclusion Node | TrainAR Documentation",
    "keywords": "Training Conclusion Node The \"TrainAR: Training Conclusion\" node is the end of the TrainAR stateflow and training. It opens a training assessment, providing an overview with various performance metrics, accumulated over the training. This e.g. includes a graph displaying the number of incorrect actions performed by the user during the training. There should be only one \"TrainAR: Training Conclusion\" node present in a TrainAR Stateflow but it can be triggered from multiple Outputs from different stateflows of the training. TrainAR Node Result"
  },
  "manual/UIActionNodes.html": {
    "href": "manual/UIActionNodes.html",
    "title": "TrainAR UI Action | TrainAR Documentation",
    "keywords": "TrainAR UI Action TrainAR: Action (UI) nodes trigger UI quizes/questionnaires for the user to complete in the TrainAR training. UI Action notes require input of the user on the user interface and the UI Action node includes different types of quizes/questionnaires in form of UI elements. To select which questionnaire type you want to use, you may change via the dropdown menu UI-Task: Questionnaire, Input Field or list selection actions. UI Task: Questionnaire If the UI Task is set to Questionnaire , the user will be shown a question and a set of predetermined answers. When the user chooses one of these answers, the user is also shown feedback. The question itself as well as the number of corresponding correct and wrong answers and their feedback have to be specified in the node. The questionnare can have between 2 and 4 possible answers. If the user inputs an answer, the stateflow resumes according to the Correct or Incorrect outputs of the node. Questionnaire nodes can also fork the Stateflow based on the given answer. TrainAR Node Result UI Task: Input Field With the UI Task set to Input Field , the user has to type in his answer to a question via the smartphones on-screen keyboard. The questions as well as all correct answers have to be specified in the node. If the user inputs an answer, the stateflow resumes according to the Correct or Incorrect outputs of the node depending on if the users answers is one of the specified correct answers or not. TrainAR Node Result UI Task: List Selection With the UI Task set to List Selection , the user is presented with a scrollable list of possible anwers, which can be defined, as well as their respective feedback, in the node. If the user chooses all correct items in the list, the Correct output is triggered. TrainAR Node Result"
  },
  "manual/VisualScripting.html": {
    "href": "manual/VisualScripting.html",
    "title": "Creating a TrainAR Stateflow | TrainAR Documentation",
    "keywords": "Creating a TrainAR Stateflow By creating a TrainAR Stateflow, you describe the procedural sequences of actions for the training you create with TrainAR. In essence, this stateflow describes at which points, which actions are expected of the user and how TrainAR reacts to those actions. For the example TrainAR training, that is shipped with the repository, the created TrainAR Training with its corresponding TrainAR Stateflow looks like this: TrainAR Nodes: The Starting Node A \"node\" is simply one element of the TrainAR stateflow. For example, the TrainAR: Onboarding completed and training assembly placed node acts as a starting point for your TrainAR Stateflow. The stateflow continues from this point, as soon as the training setup is placed. There always has to be exactly one Starting Node present in the stateflow. Connecting Node Inputs & Outputs TrainAR Nodes have various inputs and outputs. By connecting the nodes with eachother, you control the procedural flow of your training. Connecting nodes is done by connecting an output of one node with the input of another. One output can only be connected to one Input of the next node but one Input can be used from several outputs. How to fork a TrainAR Stateflow is described in detail in the Action Node documentation. TrainAR comes with 10 TrainAR-specific nodes that can be connected with each other. They are described in detail in the TrainAR Nodes documentation. As desrribed in the Advanced Options , Unitys Visual Scripting nodes can also be incorporated into the TrainAR Stateflow. Referencing TrainAR Objects in TrainAR Nodes With some nodes in TrainAR you want to reference specific TrainAR Objects , most notably, TrainAR: Action and TrainAR: Object Helper nodes . Referencing TrainAR Objects in a node is done by using the name of the TrainAR Object . This loose coupling between TrainAR Objects and the TrainAR Stateflow is deliberate as it allows to work on both independently but it requires you to use the exact name. So pay attention to upper and lower case letters as referencing by name is case sensitive. Referencing a TrainAR Object by name in the TrainAR Stateflow could for example look something like this: In this example, there is a cup as a TrainAR Object in the Hierarchy of the scene. If you want to reference this \"Cup\" in a node you simply have to use the exact name of the TrainAR Object as it is in the hierarchy as a reference. This is done in the TrainAR: Action node in the Correct object field. Conditional Outputs Some nodes have multiple outputs, which get triggered depending on what happened in your training. For example you probably want to react differently to a correct action of a user compared to an incorrect action. Consequently, Action nodes have multiple, conditional outputs. For example, if you want an \"Interaction\" on the cup by the user you could proceed to a new Action node if the user performs this action but if the user performs an incorrect action, you want to show a Feedback overlay that provides the user with additional instructions or help: The correct user action at this state is an interact on the \"Cup\" TrainAR Object. If this occures, the stateflow continues with the \"Correct\" Output, otherwise according With the \"Incorrect\" Output and displays a error feedback on the UI. Since the Incorrect path ends after the feedback node, the stateflow returns to the previous TrainAR Action node and waits for the next input by the user."
  }
}